
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Code &#8212; The Enclosure Projects</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Manufactures, Structural Transformation" href="enclosure_manuf.html" />
    <link rel="prev" title="Appendix" href="appendix.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo2.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">The Enclosure Projects</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../content.html">
                    The Enclosure Projects
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Model
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="enclosure_model.html">
   A Model of Enclosures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="appendix.html">
   Appendix
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Code
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Ideas and Extensions
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="enclosure_manuf.html">
   Manufactures, Structural Transformation
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/jhconning/enclosure_book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/notebooks/code.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Code</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="code">
<h1>Code<a class="headerlink" href="#code" title="Permalink to this headline">#</a></h1>
<p>This describes the code:</p>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>enclose API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>enclose</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Code for Enclosure projects 
# jupyter notebooks and code at https://github.com/jhconning/enclosure
# Matthew J. Baker and Jonathan Conning

# Things to fix
# plotY doesnt account for Tbar/Lbar. rescale
# check:  8/18/20 added mu option for most relevant functions
# finish: tepvt for interior private..


import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, fixed

Tbar=100
Lbar=100

def f(T, L, a=1/2, th=1):
    &#39;&#39;&#39;production technology on commons/un-enclosed land&#39;&#39;&#39;
    return th * T**(1-a) * L**a

def mple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Labor on enclosed land&#39;&#39;&#39;
    return a* f(te,le,a,th)/le  * tlbar**(1-a)

def aple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;average product of Labor &#39;&#39;&#39;
    return f(te,le,a,th)/le  * tlbar**(1-a)

def mpte(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Land on enclosed land&#39;&#39;&#39;
    return (1-a)* f(te,le,a,th)/te  * tlbar**(-a)

def mplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Labor on unenclosed land
       same tech but useful to have other name&#39;&#39;&#39;
    return mple(te, le, a, th, tlbar)

def aplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;average product of Labor on unenclosed land&#39;&#39;&#39;
    return aple(te, le, a, th, tlbar)

def Lambda(th, alp, mu):
    &#39;&#39;&#39; Key expression for private enclosure.
      mu = 0 : APL=MPL
      mu = 1 : MPL = MPL etc
    &#39;&#39;&#39;
    return ( (alp*th)/(1-mu+alp*mu) )**(1/(1-alp))


def req(te, th=1, alp=1/2, ltbar=1, mu=0):
    &#39;&#39;&#39;Decentralized Equilibrium rental&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-alp)*th * lam**alp * (1+(lam-1)*te)**(-alp) * (ltbar)**(alp)


def weq(te, th=1, alp=1/2, tlbar=1, mu =0):
    &#39;&#39;&#39;Decentralized Equilibrium wage&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-te+lam*te)**(1-alp) * (tlbar)**(1-alp)

def leo(te, th, alp):
    &#39;&#39;&#39;optimal labor allocation (from MPLe = MPLu) given enclosed land share te&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return (lam*te)/(1+lam*te-te)

def le(te, th, alp, mu):
    &#39;&#39;&#39;eqn labor share on enclosed for given te when 
       (1-mu*alp*mu)*APL=MPL  
       mu = 0:   APLc = MPLe,   le* in paper
       mu = 1:   MPLc = MPLe,   leo in paper
       mu in (0,1)   in between partly secure
       &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (lam*te)/(1+lam*te-te)

def totalq(te, th, alp, mu):
    &#39;&#39;&#39;total output in the economy given te and mu.
       Note costs of enclosure are not subtracted.&#39;&#39;&#39;
    leq = le(te, th, alp, mu)
    return f(Tbar, Lbar,alp, th) * ( th*f(te, leq, alp, th) + f(1-te, 1-leq, alp, 1) )

def plotY(th = 1, lbar = 1, alp = 0.5,  c = 1, mu=0):
    &#39;&#39;&#39;Plot total income net of clearing costs&#39;&#39;&#39;
    te = np.linspace(0, 1.0, 20)
    plt.figure(figsize=(8,6))
    plt.title(&#34;Output net of enclosure costs as function of te&#34;)
    plt.plot(te, ( totalq(te, th, alp, mu) ),  label= r&#39;total&#39; )
    plt.plot(te, ( totalq(te, th, alp, mu)-c*te*Tbar),  label= r&#39;total-cTe&#39; )
    #plt.plot(te, req(te, th, alp, lbar, mu)*te*Tbar,  label= r&#39;$r*Te$&#39;)
    #plt.plot(te, c*te*Tbar,   label= r&#39;$c*Te$&#39;)
    teo = teopt(th, alp, c, lbar)
    plt.axhline(totalq(0, th, alp, mu), xmin=0, xmax=1, linestyle=&#39;:&#39;, alpha=0.3)
    plt.xlabel(r&#39;$t_e$&#39;)
    plt.xlim(0,1), plt.ylim(70, 120)
    plt.legend()



def plotle(te=1/2, th=1, alp=1/2, mu=0.5):
    &#39;&#39;&#39;Draw edgeworth box and te/le(te) ratio&#39;&#39;&#39;
    fig, ax = plt.subplots(figsize=(7,7))
    tte = np.linspace(0,1,50)
    leq = le(te, th, alp, mu=0)
    leop = le(te, th, alp, mu=1)
    ax.set_xlim(0,1)
    ax.set_ylim(0,1)
    ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    ax.plot(tte, le(tte, th, alp, mu=0), linewidth=2)
    ax.plot(tte, le(tte, th, alp, mu=1), linewidth=2)  
    ax.plot(tte, le(tte, th, alp, mu), linewidth=2) 
    ax.plot([0,1],[0, 1],linestyle=&#39;:&#39;)
    ax.plot([0,te],[0, leq],linestyle=&#39;-&#39;)
    ax.scatter(te, leq, label=&#39;private&#39;)
    ax.scatter(te, leop, label=&#39;social&#39;)
    ax.axhline(y=leq, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axhline(y=leop, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leq, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leop, linestyle=&#39;:&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    ax.set_ylabel(r&#39;$l_e$&#39;, fontsize=15)
    #lam = (th*alp)**(1/(1-alp))
    #ax.text(0.05, 0.9, r&#39;$\theta=$&#39; +f&#39;{th: 2.1f}&#39; r&#39;, $\Lambda =$&#39;
    #      + f&#39;{lam: 3.2f}&#39; + r&#39;, $\ \ \ \frac{l_e}{t_e}=$&#39;
    #      + f&#39;{leq/(te+0.001):3.1f}&#39;, fontsize=16)
    ax.legend(loc=&#39;lower right&#39;, fontsize=14)
    print(leq, leop)


def plotreq(th=1, alp=1/2, tlbar=1, c=0, wplot=True):
    &#39;&#39;&#39;plot rental rate as function of te
       optionally also plot wages &#39;&#39;&#39;
    tte = np.linspace(0,1,50)
    fig, ax =  plt.subplots(figsize=(5,5))
    r0 = req(0, th, alp, tlbar)
    r1 = req(1, th, alp, tlbar)
    ax.set_xlim(0,1)
    #ax.set_ylim(0,2)
    ax.plot(tte, req(tte, th, alp, tlbar),  label= r&#39;$r$&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    #ax.text(1.01,r1-0.025,r&#39;$r^*(1)$&#39;,fontsize=13)
    #ax.text(-0.13,r0-0.025,r&#39;$r^*(0)$&#39;,fontsize=13)
    ax.grid()
    ax.axhline(y=c,linestyle=&#39;--&#39;, label=r&#39;$c$&#39;)
    if wplot:
        ax.plot(tte, weq(tte, th, alp, tlbar), label= r&#39;$w$&#39;)
        # plot output net of enclosure costs relative to non-enclose output.
        #ax.plot(tte,  (totalq(tte, th, alp) - c*tte*Tbar)/f(Tbar,Lbar,alp, th),label= r&#39;$net$&#39; )
        
    lam = (th*alp)**(1/(1-alp))
    ax.legend()


def plotmpts(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar, mu = 0):
    &#39;&#39;&#39;Plot partial eqn labor demand graph 
       TODO: not yet working for mu different from 0&#39;&#39;&#39;
    ll = np.linspace(0.0001, 0.9999, 400)
    leop = leo(te, th, alp)         #optimal 
    leam = le(te, th, alp, mu)      #private
    WindowsError = weq(te, th, alp, tlbar)
    we = weq(te, th, alp, tlbar)
    wo = mple(te, leop, alp, th, tlbar)
    wc = mplu(1-te, 1-leam, alp, 1, tlbar)
    fig, ax = plt.subplots(figsize=(8,6))
    #ax.spines[&#39;top&#39;].set_visible(False)
    mpe = mple(te, ll, alp, th, tlbar)
    apu = aplu(1-te, 1-ll, alp, 1, tlbar)
    mpu = mplu(1-te, 1-ll, alp, 1, tlbar)

    ax.plot(ll, mpe, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, apu, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, mpu, linewidth=2, color=&#39;k&#39;)   
    ax.fill_between(ll, mpe, mpu, 
                    where=(ll&gt;=leam)&amp;(ll&lt;=leop), 
                    hatch= &#39;//&#39;,
                    color=&#39;none&#39;,
                    edgecolor=&#39;k&#39;)

    #ax.set_xlabel(r&#39;$l_e$ - share&#39;)
    ax.vlines(x=leam, ymin=0, ymax=we, linestyle=&#39;:&#39;) 
    ax.vlines(x=leop, ymin=0, ymax=wo, 
              linestyle=&#39;:&#39;) 
    ax.axhline(we, linestyle=&#39;:&#39;)
    ax.axhline(wc, linestyle=&#39;:&#39;)
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_title(&#39;Labor Allocations, given &#39;+r&#39;$t_e$&#39;+&#39; = &#39;+f&#39;{te:2.2f}&#39;)
    ax.set_ylim(0,1.5)
    ax.set_xlim(0,1)
    ax.text(1.01, we, r&#39;$w_e$&#39;, fontsize=12)
    ax.text(1.01, wc, r&#39;$w_c$&#39;, fontsize=12)
    ax.text(leam, -0.1, r&#39;$l_e^*(t_e)$&#39;, fontsize=12,ha=&#39;center&#39;)
    ax.text(leop, -0.1, r&#39;$l_e^o(t_e)$&#39;, fontsize=12,ha=&#39;center&#39;)

    ax.annotate(r&#39;$MPL_c$&#39;,xy=(0.85, mplu(1-te, 0.15, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-30,20), fontsize=14)
    ax.annotate(r&#39;$APL_c$&#39;,xy=(0.65, aplu(1-te, 0.35, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-24,15), fontsize=14)
    ax.annotate(r&#39;$MPL_e$&#39;,xy=(0.8,  mple(te, 0.8, alp, th, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(20,-20), fontsize=14)

    labels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;0&#39;]
    xx = [leam, leam,    leop, 1, 1, 1, leam, leop,0]
    yy = [wc, we, wo, 0, we, wc, 0, 0, 0]    
    for x, y, lab in zip(xx, yy, labels):
        ax.scatter(x, y, marker=&#39;o&#39;, s=20, c =&#39;k&#39;,clip_on=False ) 
        plt.annotate(lab, (x,y), 
                textcoords=&#34;offset points&#34;, # how to position the text
                 xytext=(-5,7), # distance from text to points (x,y)
                 ha=&#39;center&#39;, fontsize=12)
    return fig, ax
   

def simplempl(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    plt.figure(figsize=(10,6))
    plt.plot(ll, mple(te, ll, alp, 1, tlbar)) 
    plt.plot(ll, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(ll, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    plt.ylim(0,2)
    plt.xlim(0,1)

def simplempl2(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, 1, tlbar))) 
    plt.plot(lnl, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(lnl, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    #plt.axvline(1-le(te, th, alp, mu=0), linestyle=&#39;-&#39;) 
    #plt.axvline(le(te, alp, th, mu=1), ymin=0, ymax=0.25, linestyle=&#39;:&#39;) 
    #plt.axhline(0.5,  linestyle=&#39;:&#39;) 
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    #plt.ylim(0,2)
    #plt.xlim(0,1)



## More plots 

def z(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $z(t_e) = \bar l^\alpha \left(1+(\Lambda^0-1)t_e\right)^{1-\alpha}-c\bar t_e$
       To find optimal enclosure rate, given MPLs equalized &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return lbar**alp * (1+(lam-1)*te)**(1-alp) 

def zprime(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $z(t_e) = \bar l^\alpha \left(1+(\Lambda^0-1)t_e\right)^{1-\alpha}-c\bar t_e$
       To find optimal enclosure rate, given MPLs equalized &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return  (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 


def teopt(th, alp, c, lbar):
    &#39;&#39;&#39;Social optimal enclosure
        zprime= derivative of z. Determines efficient enclosure. If 
        zprime(0)&lt;c  : no enclosure 
        zprime(1)&gt;c  : full enclosure
        zprime(0)&gt;c and zprime(1)&lt;c : partial enclosure
           then solve for teopt from foc
        &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    zprime = lambda te : (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 
    if zprime(0)&lt;c:
        teopt = 0
    elif zprime(1)&gt;c:
        teopt = 1
    else:
        teopt =  ( lbar * (  ((1-alp)*(lam-1))/c)**(1/alp)  - 1)/(lam-1)

    return teopt


def tepvt(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate
        req(te)= rental rate 
        r(0)&lt;c  : no enclosure 
        r(1)&gt;c  : full enclosure
        r(0)&gt;c and r(1)&lt;c : partial enclosure
           then solve for teopt from foc
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    lam = Lambda(th, alp, mu)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    if th&lt;thresh:
        if r0&gt;=c:
            tep = 1
        elif r1&lt;c:
            tep = 0
        else:
            tep = lbar * (lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))
    
    elif th&gt;= thresh:  
        if r1&gt;=c:
            tep = 1
        elif r0&lt;c:
            tep = 0
        else:
            tep = lbar * ( lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))

    return tep


def tepvt_g(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate (global game refinement)
        just like pvtpart() but adjust for global game
        If theta &lt; theta_hi then global game refinement says enclose fully if
        tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    tep = tepvt(th,alp,c, lbar, mu=0)
    
    tepg = tep
    if (tep==1) or (tep==0):
        tepg = tep
    elif (th &lt; thresh):
        if (tep &gt; 0.5):
            tepg = 0
        elif (tep &lt;= 0.5):
            tepg = 1

    return tepg



def dwl(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns DWL at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = z(teg, th, alp, lbar) - c*teg
    return  zo-zg

def dwlpct(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns actual/potential at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = z(teg, th, alp, lbar) - c*teg
    return  zg/zo


def plotz(th=1, alp=1/2, c=1, lbar=Lbar, ax=None):
    &#39;&#39;&#39;Plot z(t_e).  input ax to allow use with subplots&#39;&#39;&#39;
    if ax is None:
        fig, ax =  plt.subplots(figsize=(5,5))
    teo = teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    ax.scatter(teo, z(teo, th, alp, lbar) - c*teo, s=40, clip_on=False )
    ax.plot(tte, z(tte, th, alp, lbar) - c*tte)
    ax.set_xlim(0,1)
    ax.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar)-c*teo ,  linestyle=&#39;dashed&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    ax.set_ylabel(r&#39;$z(t_e)$&#39;)
    ax.set_title(r&#39;$z(t_e) - c\cdot t_e$&#39;)
    #return ax


def plotzprime(th, alp, c, lbar):
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    plt.scatter(teo, zprime(teo, th, alp, lbar) , s=40, clip_on=False )
    plt.axhline(c, xmin=0, xmax=1,  linestyle=&#39;dashed&#39;)
    plt.axvline(teo,  linestyle=&#39;dashed&#39;)
    plt.plot(tte, zprime(tte, th, alp, lbar))
    plt.xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    plt.ylabel(r&#39;$z(t_e)$&#39;)
    plt.title(r&#39;$z\prime(t_e) \; \mathrm{vs} \; c$&#39;)
    plt.xlim(0,1)



## Log linear MVPL plts


def plotdmg(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;like plotmpts but in logs to linearize&#39;&#39;&#39;
    ll = np.linspace(0.1, 99.9, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, th, tlbar)) ) 
    #plt.plot(lnl, np.log(mplu(te, ll, alp, 1, tlbar)))
    plt.plot(ll, aplu(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)


## Partition Diagrams from paper

def socpart(c = 1, alp= 2/3, mu =0, soc_opt= True, cond_opt=True, pv_opt=False, logpop=True):
    &#39;&#39;&#39;Plots loci determining parameter partitions corresponding to 
        Social (and Conditional Social) Optimum
        None, Full, or Partial Enclosure zones
        Option: to log plot or not
        &#39;&#39;&#39;
    start, finish  = 1.1, 2.1   # range that will be plotted
    the_1 = np.arange(start, finish, .01)
    cv = 1 / alp                          # high TFP gain threshold
    the_lo = np.arange(start, cv, .01)
    the_hi = np.arange(cv, finish, .01)
    
    ## Social Optima
    lamO = the_1**(1/(1-alp))

    lo0 = ( c / ( (lamO - 1)*(1-alp) )  ) **(1/alp)
    lo1 = lamO * lo0      

    ##### Conditional Optima:  we need separate plot ranges, each side of cv = theta_hat
    lam_hi =  Lambda(th = the_hi, alp= alp, mu = mu)

    lc  = ( c/(the_lo - 1))**(1/alp)
    lc0 = ( alp*c                  / (( lam_hi*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c                      / (the_hi*(1-alp)  ) ) **(1/alp)

    ### Private Optima
    #lam = (the_1*alp)**(1/(1-alp))
    lam = Lambda(th = the_1, alp= alp, mu = mu)
    ld0 = ( alp*c/( (1-alp)*lam)  ) **(1/alp)
    ld1 = ( c / ( the_1*(1-alp) )  ) **(1/alp)

    
    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)
        lo0, lo1 = np.log(lo0), np.log(lo1)
        ld0, ld1 = np.log(ld0), np.log(ld1)

    fig, ax = plt.subplots(figsize=(10, 8))

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)
    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=20)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=18)

    # Shift the label on the x-axis a little bit
    xpos = list(xlbl.get_position())
    xpos[0] = xpos[0]+.41
    xpos[1] = xpos[1]-.02
    ax.xaxis.set_label_coords(xpos[0], xpos[1])

    ax.set_xticks([])
    ax.set_ylim(0, 5)
    if logpop:
        ax.set_yticks([])
        ax.autoscale()
        ylbl = ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)
   
    ep = np.max(the_1)+.021

    if soc_opt:
        oline1 = ax.plot(the_1, lo0, color= &#39;black&#39;)
        bline1 = ax.plot(the_1, lo1, color= &#39;black&#39;)
        t1 = ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        t2 = ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)

    if cond_opt:
        gline1 = ax.plot(the_hi, lc0, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
        pline1 = ax.plot(the_hi, lc1, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
        bkline = ax.plot(the_lo, lc,  color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
        t3 = ax.text(ep, np.min(lc0), r&#39;$l^*_0$&#39;, fontsize=16)
        t4 = ax.text(ep, np.min(lc1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        t5 = ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_opt:
        oline1 = ax.plot(the_1, ld0, color= &#39;red&#39;)
        bline1 = ax.plot(the_1, ld1, color= &#39;red&#39;)

    vline1 = ax.axvline((1-(1-alp)*mu)/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    ax.text(cv, np.min(lo0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
    ax.text(1, np.min(lo0)-.5, r&#39;$1$&#39;, fontsize=16)

    #if cond_opt == False:
    #    fig.savefig(&#39;social_optimum.png&#39;)
    #else:
    #    fig.savefig(&#39;social_opt_cond.png&#39;)


def prvpart(c = 1, alp= 2/3, full_diag = False, logpop=True, ax=None):
# Plots the parameter regions in ln pop density - theta space

    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 8))
    start = 1.1
    finish = 2.1
    cv = 1 / alp
    the_1 = np.arange(start, finish, .01)   

    ### Truncated range for the other stuff

    the_d = np.arange(.8, finish, .01)

    the_gg = np.arange(.8, cv, .01 )

    lo0 = ( c                      / ((the_1**(1/(1-alp)) - 1)*(1-alp))  ) **(1/alp)
    lo1 = ( c*the_1**(alp/(1-alp)) / ((the_1**(1/(1-alp)) - 1)*(1-alp))  ) **(1/alp)

    if logpop:
        lo0, lo1 = np.log(lo0), np.log(lo1)

    ##### For these lines, we need separate plot ranges, so which run to the critical value
    the_r1 = np.arange(start, cv, .01)
    the_r2 = np.arange(cv, finish, .01)

    ### Conditional optimum commented out
    lam = (the_r2*alp)**(1/(1-alp))
    lc0 = ( alp*c                  / ( (1-alp) * ( lam*(1+alp) - alp) )  ) **(1/alp)
    #lc0 = ( alp*c                  / (((the_r2*alp)**(1/(1-alp))*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c                      / (the_r2*(1-alp)  ) ) **(1/alp)
    lc  = ( c/(the_r1 - 1))**(1/alp)


    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)

    ln_pd1  =  ( c / (the_d*(1-alp))) **(1/alp)  
    Lamgg = (alp*the_gg)**(1/(1-alp))
    ln_pdgg =  ( alp*c / (1-alp*the_gg) *  (1-Lamgg)/Lamgg )**(1/alp)                
    ln_pd0  =  ( alp*c / ((1-alp)*(alp*the_d)**(1/(1-alp)))  ) **(1/alp) 

    if logpop:
        ln_pd0, ln_pd1, ln_pdgg = np.log(ln_pd0), np.log(ln_pd1), np.log(ln_pdgg)

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)

    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=26)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=26)

    # Shift the label on the x-axis a little bit
    xpos = list(xlbl.get_position())
    xpos[0] = xpos[0]+.41
    xpos[1] = xpos[1]-.02
    ax.xaxis.set_label_coords(xpos[0], xpos[1])

    #ax.set_xticks([])
    ax.set_ylim(0,6)
    if logpop:
        #ax.set_yticks([])
        ax.set_ylim(-0.5,4)
        ax.autoscale()
        ylbl = ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)   

    ep = np.max(the_1)+.021
    # Conditional optimum stuff commented out...

    if full_diag:
        oline1 = ax.plot(the_1, lo0, color= &#39;black&#39;)
        bline1 = ax.plot(the_1, lo1, color= &#39;black&#39;)
    #    gline1 = ax.plot(the_r2, ln_ps0, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
    #    pline1 = ax.plot(the_r2, ln_ps1+.02, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
    #    bkline = ax.plot(the_r1, ln_ps,  color=&#39;black&#39;, linestyle=&#39;dashed&#39;)

        t1 = ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        t2 = ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)
    #    t3 = ax.text(ep, np.min(ln_ps0), r&#39;$l^*_0$&#39;, fontsize=16)
    #    t4 = ax.text(ep, np.min(ln_ps1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
    #    t5 = ax.text(cv-.1, np.min(ln_ps)+.34, r&#39;$l^*$&#39;, fontsize=16)

    ## Comment out the global game stuff..

    bbline1 = ax.plot(the_d, ln_pd0, color=&#39;red&#39;)
    bbline2 = ax.plot(the_d, ln_pd1, color=&#39;red&#39;)
    bbline3 = ax.plot(the_gg, ln_pdgg, color=&#39;red&#39;, linestyle=&#39;dashed&#39;)
  

    vline1 = ax.axvline(1/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    d1  = ax.text(ep, np.min(ln_pd0), r&#39;$l^d_0$&#39;, fontsize=16)
    dgg = ax.text(np.max(the_gg)-.3, np.min(ln_pdgg)+.4, r&#39;$l^d$&#39;, fontsize=16)

    if full_diag:
    #    d2  = ax.text(ep+.05, np.min(ln_pd1)-.07, r&#39; $l^d_1$&#39;, fontsize=16)
        d2  = ax.text(ep, np.min(ln_pd1)-.07, r&#39;$l^d_1$&#39;, fontsize=16)
    else:
        d2  = ax.text(ep, np.min(ln_pd1), r&#39;$l^d_1$&#39;, fontsize=16)

    if full_diag:
        text1 = ax.text(cv, -1, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
        text2 = ax.text(1, -1, r&#39;$1$&#39;, fontsize=16)
    else:
        text1 = ax.text(cv, np.min(ln_pd0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
        text2 = ax.text(1, np.min(ln_pd0)-.5, r&#39;$1$&#39;, fontsize=16)    

   # if full_diag:
   #     fig.savefig(&#39;nash_so_comp.png&#39;)
   # else:
   #     fig.savefig(&#39;nash_eq.png&#39;)

def threeplots(th, alp, c, lbar=2, logpop=False):
    &#39;&#39;&#39;
    axP  :  left subplot overlap social/private; mostly drawn by prvpart()
    axZ  :  top right subplot planner&#39;s  z(t_e) - c * t_e
    axZP :  bottom right subplot r vs z&#39; vs c
    
    &#39;&#39;&#39;
    fig = plt.figure(figsize=(14, 8))
    axZ= fig.add_subplot(2,2,2)
    axZP= fig.add_subplot(2,2,4)
    axP= fig.add_subplot(1,2,1)
    
    # z() plot
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    tep = tepvt(th, alp,c, lbar, mu=0)
    teg = tepvt_g(th, alp,c, lbar, mu=0)

    dwlp = dwlpct(th, alp, c, lbar)


    # top right z(t_e) - c * t_e plot
    axZ.scatter(teo, z(teo, th, alp, lbar)-c*teo, s=40, clip_on=False )
    axZ.scatter(tep, z(tep, th, alp, lbar)-c*tep, s=40, clip_on=False,color=&#39;orange&#39; )
    axZ.scatter(teg, z(teg, th, alp, lbar)-c*teg, s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )
    axZ.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar) -c*teo,  linestyle=&#39;dashed&#39;)
    axZ.axvline(tep, ymin=0, ymax=z(tep, th, alp, lbar)-c*tep ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)

    axZ.plot(tte, z(tte, th, alp, lbar) - c*tte )   
    axZ.set_xlim(0,1)
    #axZ.set_ylim(bottom=0, top=None)
    axZ.set_ylabel(r&#39;$z(t_e)-c \cdot t_e $&#39;)
    #Ypct = (z(teg, th, alp, lbar)-c*teg)/(z(teo, th, alp, lbar)-c*teo)
    axZ.set_title(f&#39;z-ct ({dwlp: .0%} potential)&#39;)


    # z prime, r and c plot
    axZP.scatter(teo, zprime(teo, th, alp, lbar), s=40, clip_on=False )
    axZP.scatter(tep, req(tep, th, alp, lbar), s=40, clip_on=False, color=&#39;orange&#39; )
    axZP.scatter(teg, req(teg, th, alp, lbar), s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )


    axZP.axvline(teo, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;)
    axZP.axvline(tep, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)
    axZP.plot(tte, zprime(tte, th, alp, lbar), label=r&#39;$z \prime$&#39; )
    axZP.set_xlim(0,1)
    axZP.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    axZP.set_ylabel(r&#39;$c, r(t_e), z \prime (t_e) $&#39;)
    axZP.axhline(c, color=&#39;red&#39;, linestyle =&#39;dashed&#39;, label=&#39;c&#39;)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    axZP.plot(tte, req(tte, th, alp, lbar),  label= &#39;$r$&#39;)
    axZP.legend()
    
    axP.scatter(th, np.log(lbar), s=40)
    axP.set_xlim(0.9, 3)
    axP.set_ylim(0, 4)
    prvpart(c=c, alp=alp, full_diag=True, logpop=True, ax = axP)
    lo, lep = leo(teo, th, alp), le(tep, th, alp, 0)
    lto, ltp = lo/(teo+0.001), lep/(tep+0.001)
    print(f&#39;optimal to ={teo:0.2f}, lo={lo:0.2f}, lo/to = {lto:0.2f};  private te={tep:0.2f}, le={lep:0.2f}, le/te = {ltp:0.2f}  &#39;)
    plt.show()
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="enclose.Lambda"><code class="name flex">
<span>def <span class="ident">Lambda</span></span>(<span>th, alp, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Key expression for private enclosure.
mu = 0 : APL=MPL
mu = 1 : MPL = MPL etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lambda(th, alp, mu):
    &#39;&#39;&#39; Key expression for private enclosure.
      mu = 0 : APL=MPL
      mu = 1 : MPL = MPL etc
    &#39;&#39;&#39;
    return ( (alp*th)/(1-mu+alp*mu) )**(1/(1-alp))</code></pre>
</details>
</dd>
<dt id="enclose.aple"><code class="name flex">
<span>def <span class="ident">aple</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>average product of Labor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;average product of Labor &#39;&#39;&#39;
    return f(te,le,a,th)/le  * tlbar**(1-a)</code></pre>
</details>
</dd>
<dt id="enclose.aplu"><code class="name flex">
<span>def <span class="ident">aplu</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>average product of Labor on unenclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;average product of Labor on unenclosed land&#39;&#39;&#39;
    return aple(te, le, a, th, tlbar)</code></pre>
</details>
</dd>
<dt id="enclose.dwl"><code class="name flex">
<span>def <span class="ident">dwl</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns DWL at each paramter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwl(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns DWL at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = z(teg, th, alp, lbar) - c*teg
    return  zo-zg</code></pre>
</details>
</dd>
<dt id="enclose.dwlpct"><code class="name flex">
<span>def <span class="ident">dwlpct</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns actual/potential at each paramter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwlpct(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns actual/potential at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = z(teg, th, alp, lbar) - c*teg
    return  zg/zo</code></pre>
</details>
</dd>
<dt id="enclose.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>T, L, a=0.5, th=1)</span>
</code></dt>
<dd>
<div class="desc"><p>production technology on commons/un-enclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(T, L, a=1/2, th=1):
    &#39;&#39;&#39;production technology on commons/un-enclosed land&#39;&#39;&#39;
    return th * T**(1-a) * L**a</code></pre>
</details>
</dd>
<dt id="enclose.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>te, th, alp, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>eqn labor share on enclosed for given te when
(1-mu<em>alp</em>mu)<em>APL=MPL<br>
mu = 0:
APLc = MPLe,
le</em> in paper
mu = 1:
MPLc = MPLe,
leo in paper
mu in (0,1)
in between partly secure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def le(te, th, alp, mu):
    &#39;&#39;&#39;eqn labor share on enclosed for given te when 
       (1-mu*alp*mu)*APL=MPL  
       mu = 0:   APLc = MPLe,   le* in paper
       mu = 1:   MPLc = MPLe,   leo in paper
       mu in (0,1)   in between partly secure
       &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (lam*te)/(1+lam*te-te)</code></pre>
</details>
</dd>
<dt id="enclose.leo"><code class="name flex">
<span>def <span class="ident">leo</span></span>(<span>te, th, alp)</span>
</code></dt>
<dd>
<div class="desc"><p>optimal labor allocation (from MPLe = MPLu) given enclosed land share te</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leo(te, th, alp):
    &#39;&#39;&#39;optimal labor allocation (from MPLe = MPLu) given enclosed land share te&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return (lam*te)/(1+lam*te-te)</code></pre>
</details>
</dd>
<dt id="enclose.mple"><code class="name flex">
<span>def <span class="ident">mple</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>marginal product of Labor on enclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Labor on enclosed land&#39;&#39;&#39;
    return a* f(te,le,a,th)/le  * tlbar**(1-a)</code></pre>
</details>
</dd>
<dt id="enclose.mplu"><code class="name flex">
<span>def <span class="ident">mplu</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>marginal product of Labor on unenclosed land
same tech but useful to have other name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Labor on unenclosed land
       same tech but useful to have other name&#39;&#39;&#39;
    return mple(te, le, a, th, tlbar)</code></pre>
</details>
</dd>
<dt id="enclose.mpte"><code class="name flex">
<span>def <span class="ident">mpte</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>marginal product of Land on enclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpte(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;marginal product of Land on enclosed land&#39;&#39;&#39;
    return (1-a)* f(te,le,a,th)/te  * tlbar**(-a)</code></pre>
</details>
</dd>
<dt id="enclose.plotY"><code class="name flex">
<span>def <span class="ident">plotY</span></span>(<span>th=1, lbar=1, alp=0.5, c=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot total income net of clearing costs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotY(th = 1, lbar = 1, alp = 0.5,  c = 1, mu=0):
    &#39;&#39;&#39;Plot total income net of clearing costs&#39;&#39;&#39;
    te = np.linspace(0, 1.0, 20)
    plt.figure(figsize=(8,6))
    plt.title(&#34;Output net of enclosure costs as function of te&#34;)
    plt.plot(te, ( totalq(te, th, alp, mu) ),  label= r&#39;total&#39; )
    plt.plot(te, ( totalq(te, th, alp, mu)-c*te*Tbar),  label= r&#39;total-cTe&#39; )
    #plt.plot(te, req(te, th, alp, lbar, mu)*te*Tbar,  label= r&#39;$r*Te$&#39;)
    #plt.plot(te, c*te*Tbar,   label= r&#39;$c*Te$&#39;)
    teo = teopt(th, alp, c, lbar)
    plt.axhline(totalq(0, th, alp, mu), xmin=0, xmax=1, linestyle=&#39;:&#39;, alpha=0.3)
    plt.xlabel(r&#39;$t_e$&#39;)
    plt.xlim(0,1), plt.ylim(70, 120)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="enclose.plotdmg"><code class="name flex">
<span>def <span class="ident">plotdmg</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>like plotmpts but in logs to linearize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotdmg(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;like plotmpts but in logs to linearize&#39;&#39;&#39;
    ll = np.linspace(0.1, 99.9, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, th, tlbar)) ) 
    #plt.plot(lnl, np.log(mplu(te, ll, alp, 1, tlbar)))
    plt.plot(ll, aplu(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)</code></pre>
</details>
</dd>
<dt id="enclose.plotle"><code class="name flex">
<span>def <span class="ident">plotle</span></span>(<span>te=0.5, th=1, alp=0.5, mu=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw edgeworth box and te/le(te) ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotle(te=1/2, th=1, alp=1/2, mu=0.5):
    &#39;&#39;&#39;Draw edgeworth box and te/le(te) ratio&#39;&#39;&#39;
    fig, ax = plt.subplots(figsize=(7,7))
    tte = np.linspace(0,1,50)
    leq = le(te, th, alp, mu=0)
    leop = le(te, th, alp, mu=1)
    ax.set_xlim(0,1)
    ax.set_ylim(0,1)
    ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    ax.plot(tte, le(tte, th, alp, mu=0), linewidth=2)
    ax.plot(tte, le(tte, th, alp, mu=1), linewidth=2)  
    ax.plot(tte, le(tte, th, alp, mu), linewidth=2) 
    ax.plot([0,1],[0, 1],linestyle=&#39;:&#39;)
    ax.plot([0,te],[0, leq],linestyle=&#39;-&#39;)
    ax.scatter(te, leq, label=&#39;private&#39;)
    ax.scatter(te, leop, label=&#39;social&#39;)
    ax.axhline(y=leq, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axhline(y=leop, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leq, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leop, linestyle=&#39;:&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    ax.set_ylabel(r&#39;$l_e$&#39;, fontsize=15)
    #lam = (th*alp)**(1/(1-alp))
    #ax.text(0.05, 0.9, r&#39;$\theta=$&#39; +f&#39;{th: 2.1f}&#39; r&#39;, $\Lambda =$&#39;
    #      + f&#39;{lam: 3.2f}&#39; + r&#39;, $\ \ \ \frac{l_e}{t_e}=$&#39;
    #      + f&#39;{leq/(te+0.001):3.1f}&#39;, fontsize=16)
    ax.legend(loc=&#39;lower right&#39;, fontsize=14)
    print(leq, leop)</code></pre>
</details>
</dd>
<dt id="enclose.plotmpts"><code class="name flex">
<span>def <span class="ident">plotmpts</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot partial eqn labor demand graph
TODO: not yet working for mu different from 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotmpts(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar, mu = 0):
    &#39;&#39;&#39;Plot partial eqn labor demand graph 
       TODO: not yet working for mu different from 0&#39;&#39;&#39;
    ll = np.linspace(0.0001, 0.9999, 400)
    leop = leo(te, th, alp)         #optimal 
    leam = le(te, th, alp, mu)      #private
    WindowsError = weq(te, th, alp, tlbar)
    we = weq(te, th, alp, tlbar)
    wo = mple(te, leop, alp, th, tlbar)
    wc = mplu(1-te, 1-leam, alp, 1, tlbar)
    fig, ax = plt.subplots(figsize=(8,6))
    #ax.spines[&#39;top&#39;].set_visible(False)
    mpe = mple(te, ll, alp, th, tlbar)
    apu = aplu(1-te, 1-ll, alp, 1, tlbar)
    mpu = mplu(1-te, 1-ll, alp, 1, tlbar)

    ax.plot(ll, mpe, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, apu, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, mpu, linewidth=2, color=&#39;k&#39;)   
    ax.fill_between(ll, mpe, mpu, 
                    where=(ll&gt;=leam)&amp;(ll&lt;=leop), 
                    hatch= &#39;//&#39;,
                    color=&#39;none&#39;,
                    edgecolor=&#39;k&#39;)

    #ax.set_xlabel(r&#39;$l_e$ - share&#39;)
    ax.vlines(x=leam, ymin=0, ymax=we, linestyle=&#39;:&#39;) 
    ax.vlines(x=leop, ymin=0, ymax=wo, 
              linestyle=&#39;:&#39;) 
    ax.axhline(we, linestyle=&#39;:&#39;)
    ax.axhline(wc, linestyle=&#39;:&#39;)
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_title(&#39;Labor Allocations, given &#39;+r&#39;$t_e$&#39;+&#39; = &#39;+f&#39;{te:2.2f}&#39;)
    ax.set_ylim(0,1.5)
    ax.set_xlim(0,1)
    ax.text(1.01, we, r&#39;$w_e$&#39;, fontsize=12)
    ax.text(1.01, wc, r&#39;$w_c$&#39;, fontsize=12)
    ax.text(leam, -0.1, r&#39;$l_e^*(t_e)$&#39;, fontsize=12,ha=&#39;center&#39;)
    ax.text(leop, -0.1, r&#39;$l_e^o(t_e)$&#39;, fontsize=12,ha=&#39;center&#39;)

    ax.annotate(r&#39;$MPL_c$&#39;,xy=(0.85, mplu(1-te, 0.15, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-30,20), fontsize=14)
    ax.annotate(r&#39;$APL_c$&#39;,xy=(0.65, aplu(1-te, 0.35, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-24,15), fontsize=14)
    ax.annotate(r&#39;$MPL_e$&#39;,xy=(0.8,  mple(te, 0.8, alp, th, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(20,-20), fontsize=14)

    labels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;0&#39;]
    xx = [leam, leam,    leop, 1, 1, 1, leam, leop,0]
    yy = [wc, we, wo, 0, we, wc, 0, 0, 0]    
    for x, y, lab in zip(xx, yy, labels):
        ax.scatter(x, y, marker=&#39;o&#39;, s=20, c =&#39;k&#39;,clip_on=False ) 
        plt.annotate(lab, (x,y), 
                textcoords=&#34;offset points&#34;, # how to position the text
                 xytext=(-5,7), # distance from text to points (x,y)
                 ha=&#39;center&#39;, fontsize=12)
    return fig, ax</code></pre>
</details>
</dd>
<dt id="enclose.plotreq"><code class="name flex">
<span>def <span class="ident">plotreq</span></span>(<span>th=1, alp=0.5, tlbar=1, c=0, wplot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>plot rental rate as function of te
optionally also plot wages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotreq(th=1, alp=1/2, tlbar=1, c=0, wplot=True):
    &#39;&#39;&#39;plot rental rate as function of te
       optionally also plot wages &#39;&#39;&#39;
    tte = np.linspace(0,1,50)
    fig, ax =  plt.subplots(figsize=(5,5))
    r0 = req(0, th, alp, tlbar)
    r1 = req(1, th, alp, tlbar)
    ax.set_xlim(0,1)
    #ax.set_ylim(0,2)
    ax.plot(tte, req(tte, th, alp, tlbar),  label= r&#39;$r$&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    #ax.text(1.01,r1-0.025,r&#39;$r^*(1)$&#39;,fontsize=13)
    #ax.text(-0.13,r0-0.025,r&#39;$r^*(0)$&#39;,fontsize=13)
    ax.grid()
    ax.axhline(y=c,linestyle=&#39;--&#39;, label=r&#39;$c$&#39;)
    if wplot:
        ax.plot(tte, weq(tte, th, alp, tlbar), label= r&#39;$w$&#39;)
        # plot output net of enclosure costs relative to non-enclose output.
        #ax.plot(tte,  (totalq(tte, th, alp) - c*tte*Tbar)/f(Tbar,Lbar,alp, th),label= r&#39;$net$&#39; )
        
    lam = (th*alp)**(1/(1-alp))
    ax.legend()</code></pre>
</details>
</dd>
<dt id="enclose.plotz"><code class="name flex">
<span>def <span class="ident">plotz</span></span>(<span>th=1, alp=0.5, c=1, lbar=100, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot z(t_e).
input ax to allow use with subplots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotz(th=1, alp=1/2, c=1, lbar=Lbar, ax=None):
    &#39;&#39;&#39;Plot z(t_e).  input ax to allow use with subplots&#39;&#39;&#39;
    if ax is None:
        fig, ax =  plt.subplots(figsize=(5,5))
    teo = teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    ax.scatter(teo, z(teo, th, alp, lbar) - c*teo, s=40, clip_on=False )
    ax.plot(tte, z(tte, th, alp, lbar) - c*tte)
    ax.set_xlim(0,1)
    ax.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar)-c*teo ,  linestyle=&#39;dashed&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    ax.set_ylabel(r&#39;$z(t_e)$&#39;)
    ax.set_title(r&#39;$z(t_e) - c\cdot t_e$&#39;)
    #return ax</code></pre>
</details>
</dd>
<dt id="enclose.plotzprime"><code class="name flex">
<span>def <span class="ident">plotzprime</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotzprime(th, alp, c, lbar):
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    plt.scatter(teo, zprime(teo, th, alp, lbar) , s=40, clip_on=False )
    plt.axhline(c, xmin=0, xmax=1,  linestyle=&#39;dashed&#39;)
    plt.axvline(teo,  linestyle=&#39;dashed&#39;)
    plt.plot(tte, zprime(tte, th, alp, lbar))
    plt.xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    plt.ylabel(r&#39;$z(t_e)$&#39;)
    plt.title(r&#39;$z\prime(t_e) \; \mathrm{vs} \; c$&#39;)
    plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.prvpart"><code class="name flex">
<span>def <span class="ident">prvpart</span></span>(<span>c=1, alp=0.6666666666666666, full_diag=False, logpop=True, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prvpart(c = 1, alp= 2/3, full_diag = False, logpop=True, ax=None):
# Plots the parameter regions in ln pop density - theta space

    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 8))
    start = 1.1
    finish = 2.1
    cv = 1 / alp
    the_1 = np.arange(start, finish, .01)   

    ### Truncated range for the other stuff

    the_d = np.arange(.8, finish, .01)

    the_gg = np.arange(.8, cv, .01 )

    lo0 = ( c                      / ((the_1**(1/(1-alp)) - 1)*(1-alp))  ) **(1/alp)
    lo1 = ( c*the_1**(alp/(1-alp)) / ((the_1**(1/(1-alp)) - 1)*(1-alp))  ) **(1/alp)

    if logpop:
        lo0, lo1 = np.log(lo0), np.log(lo1)

    ##### For these lines, we need separate plot ranges, so which run to the critical value
    the_r1 = np.arange(start, cv, .01)
    the_r2 = np.arange(cv, finish, .01)

    ### Conditional optimum commented out
    lam = (the_r2*alp)**(1/(1-alp))
    lc0 = ( alp*c                  / ( (1-alp) * ( lam*(1+alp) - alp) )  ) **(1/alp)
    #lc0 = ( alp*c                  / (((the_r2*alp)**(1/(1-alp))*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c                      / (the_r2*(1-alp)  ) ) **(1/alp)
    lc  = ( c/(the_r1 - 1))**(1/alp)


    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)

    ln_pd1  =  ( c / (the_d*(1-alp))) **(1/alp)  
    Lamgg = (alp*the_gg)**(1/(1-alp))
    ln_pdgg =  ( alp*c / (1-alp*the_gg) *  (1-Lamgg)/Lamgg )**(1/alp)                
    ln_pd0  =  ( alp*c / ((1-alp)*(alp*the_d)**(1/(1-alp)))  ) **(1/alp) 

    if logpop:
        ln_pd0, ln_pd1, ln_pdgg = np.log(ln_pd0), np.log(ln_pd1), np.log(ln_pdgg)

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)

    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=26)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=26)

    # Shift the label on the x-axis a little bit
    xpos = list(xlbl.get_position())
    xpos[0] = xpos[0]+.41
    xpos[1] = xpos[1]-.02
    ax.xaxis.set_label_coords(xpos[0], xpos[1])

    #ax.set_xticks([])
    ax.set_ylim(0,6)
    if logpop:
        #ax.set_yticks([])
        ax.set_ylim(-0.5,4)
        ax.autoscale()
        ylbl = ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)   

    ep = np.max(the_1)+.021
    # Conditional optimum stuff commented out...

    if full_diag:
        oline1 = ax.plot(the_1, lo0, color= &#39;black&#39;)
        bline1 = ax.plot(the_1, lo1, color= &#39;black&#39;)
    #    gline1 = ax.plot(the_r2, ln_ps0, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
    #    pline1 = ax.plot(the_r2, ln_ps1+.02, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
    #    bkline = ax.plot(the_r1, ln_ps,  color=&#39;black&#39;, linestyle=&#39;dashed&#39;)

        t1 = ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        t2 = ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)
    #    t3 = ax.text(ep, np.min(ln_ps0), r&#39;$l^*_0$&#39;, fontsize=16)
    #    t4 = ax.text(ep, np.min(ln_ps1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
    #    t5 = ax.text(cv-.1, np.min(ln_ps)+.34, r&#39;$l^*$&#39;, fontsize=16)

    ## Comment out the global game stuff..

    bbline1 = ax.plot(the_d, ln_pd0, color=&#39;red&#39;)
    bbline2 = ax.plot(the_d, ln_pd1, color=&#39;red&#39;)
    bbline3 = ax.plot(the_gg, ln_pdgg, color=&#39;red&#39;, linestyle=&#39;dashed&#39;)
  

    vline1 = ax.axvline(1/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    d1  = ax.text(ep, np.min(ln_pd0), r&#39;$l^d_0$&#39;, fontsize=16)
    dgg = ax.text(np.max(the_gg)-.3, np.min(ln_pdgg)+.4, r&#39;$l^d$&#39;, fontsize=16)

    if full_diag:
    #    d2  = ax.text(ep+.05, np.min(ln_pd1)-.07, r&#39; $l^d_1$&#39;, fontsize=16)
        d2  = ax.text(ep, np.min(ln_pd1)-.07, r&#39;$l^d_1$&#39;, fontsize=16)
    else:
        d2  = ax.text(ep, np.min(ln_pd1), r&#39;$l^d_1$&#39;, fontsize=16)

    if full_diag:
        text1 = ax.text(cv, -1, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
        text2 = ax.text(1, -1, r&#39;$1$&#39;, fontsize=16)
    else:
        text1 = ax.text(cv, np.min(ln_pd0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
        text2 = ax.text(1, np.min(ln_pd0)-.5, r&#39;$1$&#39;, fontsize=16)    </code></pre>
</details>
</dd>
<dt id="enclose.req"><code class="name flex">
<span>def <span class="ident">req</span></span>(<span>te, th=1, alp=0.5, ltbar=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decentralized Equilibrium rental</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def req(te, th=1, alp=1/2, ltbar=1, mu=0):
    &#39;&#39;&#39;Decentralized Equilibrium rental&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-alp)*th * lam**alp * (1+(lam-1)*te)**(-alp) * (ltbar)**(alp)</code></pre>
</details>
</dd>
<dt id="enclose.simplempl"><code class="name flex">
<span>def <span class="ident">simplempl</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplempl(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    plt.figure(figsize=(10,6))
    plt.plot(ll, mple(te, ll, alp, 1, tlbar)) 
    plt.plot(ll, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(ll, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    plt.ylim(0,2)
    plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.simplempl2"><code class="name flex">
<span>def <span class="ident">simplempl2</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplempl2(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, 1, tlbar))) 
    plt.plot(lnl, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(lnl, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    #plt.axvline(1-le(te, th, alp, mu=0), linestyle=&#39;-&#39;) 
    #plt.axvline(le(te, alp, th, mu=1), ymin=0, ymax=0.25, linestyle=&#39;:&#39;) 
    #plt.axhline(0.5,  linestyle=&#39;:&#39;) 
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    #plt.ylim(0,2)
    #plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.socpart"><code class="name flex">
<span>def <span class="ident">socpart</span></span>(<span>c=1, alp=0.6666666666666666, mu=0, soc_opt=True, cond_opt=True, pv_opt=False, logpop=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots loci determining parameter partitions corresponding to
Social (and Conditional Social) Optimum
None, Full, or Partial Enclosure zones
Option: to log plot or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def socpart(c = 1, alp= 2/3, mu =0, soc_opt= True, cond_opt=True, pv_opt=False, logpop=True):
    &#39;&#39;&#39;Plots loci determining parameter partitions corresponding to 
        Social (and Conditional Social) Optimum
        None, Full, or Partial Enclosure zones
        Option: to log plot or not
        &#39;&#39;&#39;
    start, finish  = 1.1, 2.1   # range that will be plotted
    the_1 = np.arange(start, finish, .01)
    cv = 1 / alp                          # high TFP gain threshold
    the_lo = np.arange(start, cv, .01)
    the_hi = np.arange(cv, finish, .01)
    
    ## Social Optima
    lamO = the_1**(1/(1-alp))

    lo0 = ( c / ( (lamO - 1)*(1-alp) )  ) **(1/alp)
    lo1 = lamO * lo0      

    ##### Conditional Optima:  we need separate plot ranges, each side of cv = theta_hat
    lam_hi =  Lambda(th = the_hi, alp= alp, mu = mu)

    lc  = ( c/(the_lo - 1))**(1/alp)
    lc0 = ( alp*c                  / (( lam_hi*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c                      / (the_hi*(1-alp)  ) ) **(1/alp)

    ### Private Optima
    #lam = (the_1*alp)**(1/(1-alp))
    lam = Lambda(th = the_1, alp= alp, mu = mu)
    ld0 = ( alp*c/( (1-alp)*lam)  ) **(1/alp)
    ld1 = ( c / ( the_1*(1-alp) )  ) **(1/alp)

    
    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)
        lo0, lo1 = np.log(lo0), np.log(lo1)
        ld0, ld1 = np.log(ld0), np.log(ld1)

    fig, ax = plt.subplots(figsize=(10, 8))

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)
    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=20)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=18)

    # Shift the label on the x-axis a little bit
    xpos = list(xlbl.get_position())
    xpos[0] = xpos[0]+.41
    xpos[1] = xpos[1]-.02
    ax.xaxis.set_label_coords(xpos[0], xpos[1])

    ax.set_xticks([])
    ax.set_ylim(0, 5)
    if logpop:
        ax.set_yticks([])
        ax.autoscale()
        ylbl = ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)
   
    ep = np.max(the_1)+.021

    if soc_opt:
        oline1 = ax.plot(the_1, lo0, color= &#39;black&#39;)
        bline1 = ax.plot(the_1, lo1, color= &#39;black&#39;)
        t1 = ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        t2 = ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)

    if cond_opt:
        gline1 = ax.plot(the_hi, lc0, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
        pline1 = ax.plot(the_hi, lc1, color= &#39;black&#39;, linestyle=&#39;dashed&#39;)
        bkline = ax.plot(the_lo, lc,  color=&#39;black&#39;, linestyle=&#39;dashed&#39;)
        t3 = ax.text(ep, np.min(lc0), r&#39;$l^*_0$&#39;, fontsize=16)
        t4 = ax.text(ep, np.min(lc1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        t5 = ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_opt:
        oline1 = ax.plot(the_1, ld0, color= &#39;red&#39;)
        bline1 = ax.plot(the_1, ld1, color= &#39;red&#39;)

    vline1 = ax.axvline((1-(1-alp)*mu)/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    ax.text(cv, np.min(lo0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
    ax.text(1, np.min(lo0)-.5, r&#39;$1$&#39;, fontsize=16)

    #if cond_opt == False:
    #    fig.savefig(&#39;social_optimum.png&#39;)
    #else:
    #    fig.savefig(&#39;social_opt_cond.png&#39;)</code></pre>
</details>
</dd>
<dt id="enclose.teopt"><code class="name flex">
<span>def <span class="ident">teopt</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Social optimal enclosure
zprime= derivative of z. Determines efficient enclosure. If
zprime(0)<c
: no enclosure
zprime(1)>c
: full enclosure
zprime(0)&gt;c and zprime(1)&lt;c : partial enclosure
then solve for teopt from foc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def teopt(th, alp, c, lbar):
    &#39;&#39;&#39;Social optimal enclosure
        zprime= derivative of z. Determines efficient enclosure. If 
        zprime(0)&lt;c  : no enclosure 
        zprime(1)&gt;c  : full enclosure
        zprime(0)&gt;c and zprime(1)&lt;c : partial enclosure
           then solve for teopt from foc
        &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    zprime = lambda te : (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 
    if zprime(0)&lt;c:
        teopt = 0
    elif zprime(1)&gt;c:
        teopt = 1
    else:
        teopt =  ( lbar * (  ((1-alp)*(lam-1))/c)**(1/alp)  - 1)/(lam-1)

    return teopt</code></pre>
</details>
</dd>
<dt id="enclose.tepvt"><code class="name flex">
<span>def <span class="ident">tepvt</span></span>(<span>th, alp, c, lbar, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Private enclosure rate
req(te)= rental rate
r(0)<c
: no enclosure
r(1)>c
: full enclosure
r(0)&gt;c and r(1)&lt;c : partial enclosure
then solve for teopt from foc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tepvt(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate
        req(te)= rental rate 
        r(0)&lt;c  : no enclosure 
        r(1)&gt;c  : full enclosure
        r(0)&gt;c and r(1)&lt;c : partial enclosure
           then solve for teopt from foc
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    lam = Lambda(th, alp, mu)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    if th&lt;thresh:
        if r0&gt;=c:
            tep = 1
        elif r1&lt;c:
            tep = 0
        else:
            tep = lbar * (lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))
    
    elif th&gt;= thresh:  
        if r1&gt;=c:
            tep = 1
        elif r0&lt;c:
            tep = 0
        else:
            tep = lbar * ( lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))

    return tep</code></pre>
</details>
</dd>
<dt id="enclose.tepvt_g"><code class="name flex">
<span>def <span class="ident">tepvt_g</span></span>(<span>th, alp, c, lbar, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Private enclosure rate (global game refinement)
just like pvtpart() but adjust for global game
If theta &lt; theta_hi then global game refinement says enclose fully if
tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tepvt_g(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate (global game refinement)
        just like pvtpart() but adjust for global game
        If theta &lt; theta_hi then global game refinement says enclose fully if
        tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    tep = tepvt(th,alp,c, lbar, mu=0)
    
    tepg = tep
    if (tep==1) or (tep==0):
        tepg = tep
    elif (th &lt; thresh):
        if (tep &gt; 0.5):
            tepg = 0
        elif (tep &lt;= 0.5):
            tepg = 1

    return tepg</code></pre>
</details>
</dd>
<dt id="enclose.threeplots"><code class="name flex">
<span>def <span class="ident">threeplots</span></span>(<span>th, alp, c, lbar=2, logpop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>axP
:
left subplot overlap social/private; mostly drawn by prvpart()
axZ
:
top right subplot planner's
z(t_e) - c * t_e
axZP :
bottom right subplot r vs z' vs c</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threeplots(th, alp, c, lbar=2, logpop=False):
    &#39;&#39;&#39;
    axP  :  left subplot overlap social/private; mostly drawn by prvpart()
    axZ  :  top right subplot planner&#39;s  z(t_e) - c * t_e
    axZP :  bottom right subplot r vs z&#39; vs c
    
    &#39;&#39;&#39;
    fig = plt.figure(figsize=(14, 8))
    axZ= fig.add_subplot(2,2,2)
    axZP= fig.add_subplot(2,2,4)
    axP= fig.add_subplot(1,2,1)
    
    # z() plot
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    tep = tepvt(th, alp,c, lbar, mu=0)
    teg = tepvt_g(th, alp,c, lbar, mu=0)

    dwlp = dwlpct(th, alp, c, lbar)


    # top right z(t_e) - c * t_e plot
    axZ.scatter(teo, z(teo, th, alp, lbar)-c*teo, s=40, clip_on=False )
    axZ.scatter(tep, z(tep, th, alp, lbar)-c*tep, s=40, clip_on=False,color=&#39;orange&#39; )
    axZ.scatter(teg, z(teg, th, alp, lbar)-c*teg, s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )
    axZ.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar) -c*teo,  linestyle=&#39;dashed&#39;)
    axZ.axvline(tep, ymin=0, ymax=z(tep, th, alp, lbar)-c*tep ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)

    axZ.plot(tte, z(tte, th, alp, lbar) - c*tte )   
    axZ.set_xlim(0,1)
    #axZ.set_ylim(bottom=0, top=None)
    axZ.set_ylabel(r&#39;$z(t_e)-c \cdot t_e $&#39;)
    #Ypct = (z(teg, th, alp, lbar)-c*teg)/(z(teo, th, alp, lbar)-c*teo)
    axZ.set_title(f&#39;z-ct ({dwlp: .0%} potential)&#39;)


    # z prime, r and c plot
    axZP.scatter(teo, zprime(teo, th, alp, lbar), s=40, clip_on=False )
    axZP.scatter(tep, req(tep, th, alp, lbar), s=40, clip_on=False, color=&#39;orange&#39; )
    axZP.scatter(teg, req(teg, th, alp, lbar), s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )


    axZP.axvline(teo, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;)
    axZP.axvline(tep, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)
    axZP.plot(tte, zprime(tte, th, alp, lbar), label=r&#39;$z \prime$&#39; )
    axZP.set_xlim(0,1)
    axZP.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    axZP.set_ylabel(r&#39;$c, r(t_e), z \prime (t_e) $&#39;)
    axZP.axhline(c, color=&#39;red&#39;, linestyle =&#39;dashed&#39;, label=&#39;c&#39;)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    axZP.plot(tte, req(tte, th, alp, lbar),  label= &#39;$r$&#39;)
    axZP.legend()
    
    axP.scatter(th, np.log(lbar), s=40)
    axP.set_xlim(0.9, 3)
    axP.set_ylim(0, 4)
    prvpart(c=c, alp=alp, full_diag=True, logpop=True, ax = axP)
    lo, lep = leo(teo, th, alp), le(tep, th, alp, 0)
    lto, ltp = lo/(teo+0.001), lep/(tep+0.001)
    print(f&#39;optimal to ={teo:0.2f}, lo={lo:0.2f}, lo/to = {lto:0.2f};  private te={tep:0.2f}, le={lep:0.2f}, le/te = {ltp:0.2f}  &#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="enclose.totalq"><code class="name flex">
<span>def <span class="ident">totalq</span></span>(<span>te, th, alp, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>total output in the economy given te and mu.
Note costs of enclosure are not subtracted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def totalq(te, th, alp, mu):
    &#39;&#39;&#39;total output in the economy given te and mu.
       Note costs of enclosure are not subtracted.&#39;&#39;&#39;
    leq = le(te, th, alp, mu)
    return f(Tbar, Lbar,alp, th) * ( th*f(te, leq, alp, th) + f(1-te, 1-leq, alp, 1) )</code></pre>
</details>
</dd>
<dt id="enclose.weq"><code class="name flex">
<span>def <span class="ident">weq</span></span>(<span>te, th=1, alp=0.5, tlbar=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decentralized Equilibrium wage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weq(te, th=1, alp=1/2, tlbar=1, mu =0):
    &#39;&#39;&#39;Decentralized Equilibrium wage&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-te+lam*te)**(1-alp) * (tlbar)**(1-alp)</code></pre>
</details>
</dd>
<dt id="enclose.z"><code class="name flex">
<span>def <span class="ident">z</span></span>(<span>te, th, alp, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>output per unit land net of enclosure cost
$z(t_e) = ar l^lpha \left(1+(\Lambda^0-1)t_e
ight)^{1-lpha}-car t_e$
To find optimal enclosure rate, given MPLs equalized</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def z(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $z(t_e) = \bar l^\alpha \left(1+(\Lambda^0-1)t_e\right)^{1-\alpha}-c\bar t_e$
       To find optimal enclosure rate, given MPLs equalized &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return lbar**alp * (1+(lam-1)*te)**(1-alp) </code></pre>
</details>
</dd>
<dt id="enclose.zprime"><code class="name flex">
<span>def <span class="ident">zprime</span></span>(<span>te, th, alp, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>output per unit land net of enclosure cost
$z(t_e) = ar l^lpha \left(1+(\Lambda^0-1)t_e
ight)^{1-lpha}-car t_e$
To find optimal enclosure rate, given MPLs equalized</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zprime(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $z(t_e) = \bar l^\alpha \left(1+(\Lambda^0-1)t_e\right)^{1-\alpha}-c\bar t_e$
       To find optimal enclosure rate, given MPLs equalized &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return  (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="enclose.Lambda" href="#enclose.Lambda">Lambda</a></code></li>
<li><code><a title="enclose.aple" href="#enclose.aple">aple</a></code></li>
<li><code><a title="enclose.aplu" href="#enclose.aplu">aplu</a></code></li>
<li><code><a title="enclose.dwl" href="#enclose.dwl">dwl</a></code></li>
<li><code><a title="enclose.dwlpct" href="#enclose.dwlpct">dwlpct</a></code></li>
<li><code><a title="enclose.f" href="#enclose.f">f</a></code></li>
<li><code><a title="enclose.le" href="#enclose.le">le</a></code></li>
<li><code><a title="enclose.leo" href="#enclose.leo">leo</a></code></li>
<li><code><a title="enclose.mple" href="#enclose.mple">mple</a></code></li>
<li><code><a title="enclose.mplu" href="#enclose.mplu">mplu</a></code></li>
<li><code><a title="enclose.mpte" href="#enclose.mpte">mpte</a></code></li>
<li><code><a title="enclose.plotY" href="#enclose.plotY">plotY</a></code></li>
<li><code><a title="enclose.plotdmg" href="#enclose.plotdmg">plotdmg</a></code></li>
<li><code><a title="enclose.plotle" href="#enclose.plotle">plotle</a></code></li>
<li><code><a title="enclose.plotmpts" href="#enclose.plotmpts">plotmpts</a></code></li>
<li><code><a title="enclose.plotreq" href="#enclose.plotreq">plotreq</a></code></li>
<li><code><a title="enclose.plotz" href="#enclose.plotz">plotz</a></code></li>
<li><code><a title="enclose.plotzprime" href="#enclose.plotzprime">plotzprime</a></code></li>
<li><code><a title="enclose.prvpart" href="#enclose.prvpart">prvpart</a></code></li>
<li><code><a title="enclose.req" href="#enclose.req">req</a></code></li>
<li><code><a title="enclose.simplempl" href="#enclose.simplempl">simplempl</a></code></li>
<li><code><a title="enclose.simplempl2" href="#enclose.simplempl2">simplempl2</a></code></li>
<li><code><a title="enclose.socpart" href="#enclose.socpart">socpart</a></code></li>
<li><code><a title="enclose.teopt" href="#enclose.teopt">teopt</a></code></li>
<li><code><a title="enclose.tepvt" href="#enclose.tepvt">tepvt</a></code></li>
<li><code><a title="enclose.tepvt_g" href="#enclose.tepvt_g">tepvt_g</a></code></li>
<li><code><a title="enclose.threeplots" href="#enclose.threeplots">threeplots</a></code></li>
<li><code><a title="enclose.totalq" href="#enclose.totalq">totalq</a></code></li>
<li><code><a title="enclose.weq" href="#enclose.weq">weq</a></code></li>
<li><code><a title="enclose.z" href="#enclose.z">z</a></code></li>
<li><code><a title="enclose.zprime" href="#enclose.zprime">zprime</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html></section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="appendix.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Appendix</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="enclosure_manuf.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Manufactures, Structural Transformation</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Matthew J. Baker and Jonathan Conning<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>