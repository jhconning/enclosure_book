<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>enclose API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>enclose</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Code for Enclosure projects 
# jupyter notebooks and code at https://github.com/jhconning/enclosure
# Matthew J. Baker and Jonathan Conning

__version__ = &#39;dev&#39;
# NOTES
&#39;&#39;&#39;
This module contains functions for the analysis of a model of private land enclosures.
The docstrings can use pdoc3 to generate documention for the API using command:
   `pdoc --html --force --output-dir docs -c latex_math=True enclose.py`
This will generate a html file in the docs directory. 
In pdoc all latex backslashes must be escaped (e.g. \\alpha) and math delimeter is $$.

TODO:
- The parameter $mu$ is represented in some but not all functions
  (to analyze case where partial security)
- finalize the manufacturing case
&#39;&#39;&#39;

import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, fixed
from IPython.display import display, Math, Markdown

Tbar=100
Lbar=100

def f(T, L, a=1/2, th=1):
    r&#39;&#39;&#39;Production technology 
       $$f(T, L) = \theta \cdot T^{1-\alpha}L^{\alpha}$$ 
       &#39;&#39;&#39;
    return th * T**(1-a) * L**a

def mple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    r&#39;&#39;&#39;Marginal product of Labor on enclosed land can be written
       $$MPL(t_e, l_e) = \alpha \cdot \frac{f(t_e, l_e)}{l_e} \bar l^\alpha$$ 
       Since with a Cobb Douglas, $MPL = \alpha \cdot APL$.&#39;&#39;&#39;
    return a* f(te,le,a,th)/le  * tlbar**(1-a)

def aple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    r&#39;&#39;&#39;Average product of Labor 
    $$APL(t_e, l_e) = \frac{f(T_e, L_e)}{L_e} =  \frac{f(t_e, l_e)}{l_e} \cdot \bar t^{1-\alpha}$$ 
    &#39;&#39;&#39;
    return f(te,le,a,th)/le  * tlbar**(1-a)

def mpte(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Marginal product of Land on enclosed land&#39;&#39;&#39;
    return (1-a)* f(te,le,a,th)/te  * tlbar**(-a)

def mplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Marginal product of Labor on unenclosed land
       same tech but useful to have other name&#39;&#39;&#39;
    return mple(te, le, a, th, tlbar)

def aplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Average product of Labor on unenclosed land&#39;&#39;&#39;
    return aple(te, le, a, th, tlbar)

def Lambda(th, alp, mu):
    &#39;&#39;&#39; Key term in expressions. Can return either private or planners 
    Lambda:
    $$\\mu = 0 \\rightarrow \\Lambda = (\\alpha \\theta)^\\frac{1}{1-\\alpha}$$
    $$\\mu = 1 \\rightarrow \\Lambda_o = \\theta^\\frac{1}{1-\\alpha}$$
    &#39;&#39;&#39;
    return ( (alp*th)/(1-mu+alp*mu) )**(1/(1-alp))

def req(te, th=1, alp=1/2, ltbar=1, mu=0):
    r&#39;&#39;&#39;Decentralized Equilibrium rental given t_e
       $$r(t_e) =  \theta f_T(t_e, l_e(t_e)) \cdot \bar l^\alpha$$ 
       $$r(t_e) =  \frac{(1-\alpha) \theta  \Lambda^\alpha}{(1+(\Lambda-1)t_e)^\alpha}  \cdot \bar l^\alpha$$ 

    &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-alp)*th * lam**alp * (1+(lam-1)*te)**(-alp) * (ltbar)**(alp)

def weq(te, th=1, alp=1/2, tlbar=1, mu=0):
    &#39;&#39;&#39;Decentralized Equilibrium wage&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1+(lam-1)*te)**(1-alp) * (tlbar)**(1-alp)

def leo(te, th, alp):
    &#39;&#39;&#39;optimal labor allocation (from MPLe = MPLu) given enclosed land share te&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return (lam*te)/(1+lam*te-te)

def le(te, th, alp, mu):
    &#39;&#39;&#39;Private equilibrium labor share on enclosed for given te when 
       (1-mu*alp*mu)*APL=MPL  
       mu = 0:   APLc = MPLe,   le* in paper
       mu = 1:   MPLc = MPLe,   leo in paper
       mu in (0,1)   in between partly secure
       &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (lam*te)/(1+(lam-1)*te)

def totalq(te, th, alp, lbar, mu):
    &#39;&#39;&#39;total output in the economy given te and mu.
       Note costs of enclosure are not subtracted.&#39;&#39;&#39;
    leq = le(te, th, alp, mu)
    return ( th * f(te, leq, alp, th) + f(1-te, 1-leq, alp, 1) ) * lbar**alp 


def z(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $$z(t_e) = \\bar l^\\alpha \\left(1+(\\Lambda_o-1)t_e\\right)^{1-\\alpha}$$ &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return lbar**alp * (1+(lam-1)*te)**(1-alp) 

def zpv(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost  NEED TO ADJUST:
       $$z_d(t_e)= \\bar l^\\alpha \\cdot \\frac{ 1+(\\frac{\\Lambda}{\\alpha}-1)t_e}{(1+(\\Lambda-1)t_e)^\\alpha}$$
  &#39;&#39;&#39;
    lam = (alp*th)**(1/(1-alp))
    return lbar**alp * (th*te*lam**alp +(1-te))/(1+(lam-1)*te)**alp 



def zprime(te, th, alp, lbar):
    &#39;&#39;&#39;derivative of planner&#39;s z(t_e) function
       $$z(t_e) = \\bar l^\\alpha \\cdot (1-\\alpha)(\\Lambda_o -1) \\left(1+(\\Lambda_o-1)t_e \\right)^{-\\alpha}$$
       &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return  (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 


def teopt(th, alp, c, lbar):
    &#39;&#39;&#39;Planner enclosure rate. If partial then
    $$t_e^o =  \\frac{\\bar l}{(\\Lambda_o - 1)} 
    \\left [   \\frac{(1-\\alpha)(\\Lambda_o - 1)}{c} 
    \\right ]^\\frac{1}{\\alpha} - \\frac{1}{(\\Lambda_o - 1)}
    $$&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    zprime = lambda te : (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 
    if zprime(0)&lt;c:
        teopt = 0
    elif zprime(1)&gt;c:
        teopt = 1
    else:
        teopt =  ( lbar * (  ((1-alp)*(lam-1))/c)**(1/alp)  - 1)/(lam-1)

    return teopt


def tepvt(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate
        req(te)= rental rate 
        r(0)&lt;c  : no enclosure 
        r(1)&gt;c  : full enclosure
        r(0)&gt;c and r(1)&lt;c : partial enclosure
           then solve for teopt from foc

        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    lam = Lambda(th, alp, mu)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    if th&lt;thresh:
        if r0&gt;=c:
            tep = 1
        elif r1&lt;c:
            tep = 0
        else:
            tep = lbar * (lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))
    
    elif th&gt;= thresh:  
        if r1&gt;=c:
            tep = 1
        elif r0&lt;c:
            tep = 0
        else:
            tep = lbar * ( lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))

    return tep


def tepvt_g(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate (global game refinement)
        just like pvtpart() but adjust for global game
        If theta &lt; theta_hi then global game refinement says enclose fully if
        tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    tep = tepvt(th,alp,c, lbar, mu=0)
    
    tepg = tep
    if (tep==1) or (tep==0):
        tepg = tep
    elif (th &lt; thresh):
        if (tep &gt; 0.5):
            tepg = 0
        elif (tep &lt;= 0.5):
            tepg = 1

    return tepg



def dwl(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns DWL at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = zpv(teg, th, alp, lbar) - c*teg
    return  zo, zg

def dwlpct(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns actual/potential at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    if th &gt; (1/alp):
        tep = tepvt(th,alp,c, lbar, mu=0)
    else:
        tep = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = zpv(tep, th, alp, lbar) - c*tep
    return  zg/zo



## Plotting functions

def plotY(th=1, lbar = 1, alp = 0.5,  c = 1, mu=0):
    &#39;&#39;&#39;Plot total income net of clearing costs&#39;&#39;&#39;
    tte = np.linspace(0, 1.0, 20)
    plt.figure(figsize=(8,6))
    plt.title(&#34;Output net of enclosure costs as function of te&#34;)
    plt.plot(tte, ( z(tte, th, alp, lbar) - c*tte ),  label= r&#39;z-cTe&#39; )
    plt.plot(tte, ( z(tte, alp*th, alp, lbar) - c*tte),  label= r&#39;total-cTe&#39; )
    #plt.plot(te, req(te, th, alp, lbar, mu)*te*Tbar,  label= r&#39;$r*Te$&#39;)
    #plt.plot(te, c*te*Tbar,   label= r&#39;$c*Te$&#39;)
    teo = teopt(th, alp, c, lbar)
    plt.axhline(totalq(0, th, alp, lbar, mu), xmin=0, xmax=1, linestyle=&#39;:&#39;, alpha=0.3)
    plt.xlabel(r&#39;$t_e$&#39;)
    plt.xlim(0,1)
    plt.legend()



def plotle(te=1/2, th=1, alp=1/2, mu=0.5):
    &#39;&#39;&#39;Draw edgeworth box and te/le(te) ratio&#39;&#39;&#39;
    fig, ax = plt.subplots(figsize=(7,7))
    tte = np.linspace(0,1,50)
    leq = le(te, th, alp, mu=0)
    leop = le(te, th, alp, mu=1)
    ax.set_xlim(0,1)
    ax.set_ylim(0,1)
    ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    ax.plot(tte, le(tte, th, alp, mu=0), linewidth=2)
    ax.plot(tte, le(tte, th, alp, mu=1), linewidth=2)  
    ax.plot(tte, le(tte, th, alp, mu), linewidth=2) 
    ax.plot([0,1],[0, 1],linestyle=&#39;:&#39;)
    ax.plot([0,te],[0, leq],linestyle=&#39;-&#39;)
    ax.scatter(te, leq, label=&#39;private&#39;)
    ax.scatter(te, leop, label=&#39;social&#39;)
    ax.axhline(y=leq, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axhline(y=leop, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leq, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leop, linestyle=&#39;:&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    ax.set_ylabel(r&#39;$l_e$&#39;, fontsize=15)
    #lam = (th*alp)**(1/(1-alp))
    #ax.text(0.05, 0.9, r&#39;$\theta=$&#39; +f&#39;{th: 2.1f}&#39; r&#39;, $\Lambda =$&#39;
    #      + f&#39;{lam: 3.2f}&#39; + r&#39;, $\ \ \ \frac{l_e}{t_e}=$&#39;
    #      + f&#39;{leq/(te+0.001):3.1f}&#39;, fontsize=16)
    ax.legend(loc=&#39;lower right&#39;, fontsize=14)
    print(leq, leop)


def plotreq(th=1, alp=1/2, tlbar=1, c=0, wplot=True):
    &#39;&#39;&#39;plot rental rate as function of te
       optionally also plot wages &#39;&#39;&#39;
    tte = np.linspace(0,1,50)
    fig, ax =  plt.subplots(figsize=(5,5))
    r0 = req(0, th, alp, tlbar)
    r1 = req(1, th, alp, tlbar)
    ax.set_xlim(0,1)
    #ax.set_ylim(0,2)
    ax.plot(tte, req(tte, th, alp, tlbar),  label= r&#39;$r$&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    #ax.text(1.01,r1-0.025,r&#39;$r^*(1)$&#39;,fontsize=13)
    #ax.text(-0.13,r0-0.025,r&#39;$r^*(0)$&#39;,fontsize=13)
    ax.grid()
    ax.axhline(y=c,linestyle=&#39;--&#39;, label=r&#39;$c$&#39;)
    if wplot:
        ax.plot(tte, weq(tte, th, alp, tlbar), label= r&#39;$w$&#39;)
        # plot output net of enclosure costs relative to non-enclose output.
        #ax.plot(tte,  (totalq(tte, th, alp) - c*tte*Tbar)/f(Tbar,Lbar,alp, th),label= r&#39;$net$&#39; )
        
    lam = (th*alp)**(1/(1-alp))
    ax.legend()


def plotmpts(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar, mu = 0):
    &#39;&#39;&#39;Plot partial eqn labor demand graph 
       TODO: not yet working for mu different from 0&#39;&#39;&#39;
    ll = np.linspace(0.0001, 0.9999, 400)
    leop = leo(te, th, alp)         #optimal 
    leam = le(te, th, alp, mu)      #private
    we = weq(te, th, alp, tlbar)
    wo = mple(te, leop, alp, th, tlbar)
    wc = mplu(1-te, 1-leam, alp, 1, tlbar)
    mpe = mple(te, ll, alp, th, tlbar)
    apu = aplu(1-te, 1-ll, alp, 1, tlbar)
    mpu = mplu(1-te, 1-ll, alp, 1, tlbar)

    fig, ax = plt.subplots(figsize=(8,6))
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.plot(ll, mpe, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, apu, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, mpu, linewidth=2, color=&#39;k&#39;)   
    ax.fill_between(ll, mpe, mpu, 
                    where=(ll&gt;=leam)&amp;(ll&lt;=leop), 
                    hatch= &#39;//&#39;,
                    color=&#39;none&#39;,
                    edgecolor=&#39;k&#39;)
    ax.vlines(x=leam, ymin=0, ymax=we, linestyle=&#39;:&#39;) 
    ax.vlines(x=leop, ymin=0, ymax=wo, 
              linestyle=&#39;:&#39;) 
    ax.axhline(we, linestyle=&#39;:&#39;)
    ax.axhline(wc, linestyle=&#39;:&#39;)
    ax.set_ylim(0,1.5)
    ax.set_xlim(0,1)
    ax.annotate(r&#39;$MP_L^c$&#39;,xy=(0.85, mplu(1-te, 0.15, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-30,20), fontsize=14)
    ax.annotate(r&#39;$AP_L^c$&#39;,xy=(0.65, aplu(1-te, 0.35, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-24,15), fontsize=14)
    ax.annotate(r&#39;$MP_L^e$&#39;,xy=(0.8,  mple(te, 0.8, alp, th, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(20,-20), fontsize=14)

    xlabels = [&#39;0&#39;, r&#39;$l_e^*(t_e)$&#39;, r&#39;$l_e^o(t_e)$&#39;,&#39;1&#39;]
    ylabels = [&#39;&#39;,r&#39;$w_e$&#39;, r&#39;$w_c$&#39;, r&#39;$w_o$&#39;]
    ax.set_xticks([0, leam, leop, 1],xlabels, fontsize=13)
    #ax.set_yticks([0, we, wc, wo], ylabels, fontsize=13)

    labels = [&#39;A&#39;, &#39;  C&#39;, &#39;  E&#39;,   &#39;&#39;, &#39;&#39;]
    xx = [leam, leam, leop, leam, leop]
    yy = [wc,   we,   wo,   0,    0]    
    for x, y, lab in zip(xx, yy, labels):
        ax.scatter(x, y, marker=&#39;o&#39;, s=30, c =&#39;k&#39;,clip_on=False ) 
        plt.annotate(lab, (x,y), 
                textcoords=&#34;offset points&#34;, # how to position the text
                 xytext=(-5,7), # distance from text to points (x,y)
                 ha=&#39;center&#39;, fontsize=12)
    return fig, ax
   

def simplempl(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    plt.figure(figsize=(10,6))
    plt.plot(ll, mple(te, ll, alp, 1, tlbar)) 
    plt.plot(ll, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(ll, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    plt.ylim(0,2)
    plt.xlim(0,1)

def simplempl2(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, 1, tlbar))) 
    plt.plot(lnl, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(lnl, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    #plt.axvline(1-le(te, th, alp, mu=0), linestyle=&#39;-&#39;) 
    #plt.axvline(le(te, alp, th, mu=1), ymin=0, ymax=0.25, linestyle=&#39;:&#39;) 
    #plt.axhline(0.5,  linestyle=&#39;:&#39;) 
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    #plt.ylim(0,2)
    #plt.xlim(0,1)



## More plots 


def plotz(th=1, alp=1/2, c=1, lbar=Lbar, ax=None):
    &#39;&#39;&#39;Plot z(t_e).  input ax to allow use with subplots&#39;&#39;&#39;
    if ax is None:
        fig, ax =  plt.subplots(figsize=(5,5))
    teo = teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    ax.scatter(teo, z(teo, th, alp, lbar) - c*teo, s=40, clip_on=False )
    ax.plot(tte, z(tte, th, alp, lbar) - c*tte)
    #ax.plot(tte, z(tte, th, alp, lbar) )
    ax.set_xlim(0,1)
    ax.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar)-c*teo ,  linestyle=&#39;dashed&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    ax.set_ylabel(r&#39;$z(t_e)$&#39;)
    ax.set_title(r&#39;$z(t_e) - c\cdot t_e$&#39;)
    


def plotzprime(th, alp, c, lbar):
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    plt.scatter(teo, zprime(teo, th, alp, lbar) , s=40, clip_on=False )
    plt.axhline(c, xmin=0, xmax=1,  linestyle=&#39;dashed&#39;)
    plt.axvline(teo,  linestyle=&#39;dashed&#39;)
    plt.plot(tte, zprime(tte, th, alp, lbar))
    plt.xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    plt.ylabel(r&#39;$z(t_e)$&#39;)
    plt.title(r&#39;$z\prime(t_e) \; \mathrm{vs} \; c$&#39;)
    plt.xlim(0,1)



## Log linear MVPL plts


def plotdmg(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;like plotmpts but in logs to linearize&#39;&#39;&#39;
    ll = np.linspace(0.1, 99.9, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, th, tlbar)) ) 
    #plt.plot(lnl, np.log(mplu(te, ll, alp, 1, tlbar)))
    plt.plot(ll, aplu(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)


## Partition Diagrams from paper

def allpart(c = 1, alp= 2/3, mu =0, soc_opt= True, cond_opt=True, pv_opt=False, pv_gg=True,logpop=True, ax=None):
    &#39;&#39;&#39;Plot loci determining parameter partitions corresponding to 
        Social (and Conditional Social) Optimum
        None, Full, or Partial Enclosure zones
        Option: to log plot or not
        &#39;&#39;&#39;
    # for aesthetics we have different plot domains for the different loci    
    lostart, start, finish, step  = 0.8, 1.1, 2.1, 0.01   # domain boundary points
    cv = 1 / alp                          # high TFP gain threshold 
    the_1 = np.arange(start, finish, step)
    the_lo = np.arange(start, cv, step)
    the_hi = np.arange(cv, finish, step)
    the_gg = np.arange(lostart, cv, step)  # below high threshold
    the_d = np.arange(lostart, finish, step)      # above high threshold
    
    ## Social Optima
    lamO = the_1**(1/(1-alp))
    lo0 = ( c / ( (lamO - 1)*(1-alp) )  ) **(1/alp)
    lo1 = lamO * lo0      

    ##### Conditional Optima:  separate plot ranges, each side of cv = theta_hat
    lam_hi =  Lambda(th = the_hi, alp= alp, mu = mu)
    lc  = ( c/(the_lo - 1))**(1/alp)
    lc0 = ( alp*c / (( lam_hi*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c     / (the_hi*(1-alp)  ) ) **(1/alp)

    ### Private Decentralized equilibia
    lam = Lambda(th = the_d, alp= alp, mu = mu)
    ld0 = ( alp*c/( (1-alp)*lam)  ) **(1/alp)
    ld1 = ( c / ( the_d*(1-alp) )  ) **(1/alp)
    lamg = Lambda(th = the_gg, alp= alp, mu = mu)
    ldg =  ( alp*c / (1-alp*the_gg) *  (1-lamg)/lamg )**(1/alp)     

    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 8))

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)
    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=20)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=18)
    xpos = list(xlbl.get_position())      # Shift the label on the x-axis a little bit
    ax.xaxis.set_label_coords(xpos[0]+0.41, xpos[1]-0.02)
    ax.set_xticks([])

    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)
        lo0, lo1 = np.log(lo0), np.log(lo1)
        ld0, ld1, ldg = np.log(ld0), np.log(ld1), np.log(ldg)

        ax.set_yticks([])
        ax.autoscale()
        ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)
   
    ep = np.max(the_1)+.021  # end point for plot   

    if soc_opt:
        slocus0 = ax.plot(the_1, lo0, color= &#39;black&#39;, alpha=0.2)
        slocus1 = ax.plot(the_1, lo1, color= &#39;black&#39;, alpha=0.2)
        ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)

    if cond_opt:
        clocus_lo = ax.plot(the_lo, lc,  color=&#39;blue&#39;, linestyle=&#39;dashed&#39;)
        clocus0 = ax.plot(the_hi, lc0, color= &#39;blue&#39;, linestyle=&#39;dashed&#39;)
        clocus1 = ax.plot(the_hi, lc1, color= &#39;blue&#39;, linestyle=&#39;dashed&#39;,linewidth=2.5)
    
        t3 = ax.text(ep, np.min(lc0), r&#39;$l^c_0$&#39;, fontsize=16)
        t4 = ax.text(ep, np.min(lc1)-.05, r&#39;$l^c_1$&#39;, fontsize=16)
        #t5 = ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_opt:
        oline1 = ax.plot(the_d, ld0, color= &#39;red&#39;)
        bline1 = ax.plot(the_d, ld1, color= &#39;red&#39;)
        bbline3 = ax.plot(the_gg, ldg, color=&#39;red&#39;, linestyle=&#39;dashed&#39;)
        ax.text(ep, np.min(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(lostart, np.max(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(ep, np.min(ld1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        ax.text(lostart, np.max(ld1), r&#39;$l^*_1$&#39;, fontsize=16)
        #ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_gg:     # plot just the global game locus below the threshold
        above = len(the_gg)
        ax.plot(the_d[above:], ld0[above:], color= &#39;red&#39;)
        ax.plot(the_d[above:], ld1[above:], color= &#39;red&#39;)
        ax.plot(the_gg, ldg, color=&#39;red&#39;, linestyle=&#39;-&#39;)
        ax.text(ep, np.min(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(ep, np.min(ld1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        ax.text(lostart, np.max(ldg)-.04, r&#39;$l^g$&#39;, fontsize=16)

    vline1 = ax.axvline((1-(1-alp)*mu)/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    ax.text(cv, np.min(lo0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
    ax.text(1, np.min(lo0)-.5, r&#39;$1$&#39;, fontsize=16)




    #if cond_opt == False:
    #    fig.savefig(&#39;social_optimum.png&#39;)
    #else:
    #    fig.savefig(&#39;social_opt_cond.png&#39;)

def threeplots(th, alp, c, lbar=2, soc_opt= True, cond_opt=True, pv_opt=False, pv_gg=True, logpop=False):
    &#39;&#39;&#39;
    axP  :  left subplot overlap social/private; mostly drawn by allpart()
    axZ  :  top right subplot planner&#39;s  z(t_e) - c * t_e etc
    axZP :  bottom right subplot r vs z&#39; vs c
    
    &#39;&#39;&#39;
    fig  = plt.figure(figsize=(14, 8))
    axP  = fig.add_subplot(1,2,1)
    axZ  = fig.add_subplot(2,2,2)
    axZP = fig.add_subplot(2,2,4)
    #axl  = fig.add_subplot(2,4,8)
    
    # z() plot
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    tep = tepvt(th, alp,c, lbar, mu=0)
    teg = tepvt_g(th, alp,c, lbar, mu=0)

    dwlp = dwlpct(th, alp, c, lbar)
    zo, zg = dwl(th, alp, c, lbar)


    # top right z(t_e) - c * t_e plot
    axZ.scatter(teo, z(teo, th, alp, lbar)-c*teo, s=40, clip_on=False)
    axZ.scatter(tep, zpv(tep, th, alp, lbar) - c*tep, s=40, clip_on=False,color=&#39;orange&#39; )  
    axZ.scatter(teg, zpv(teg, th, alp, lbar) - c*teg, s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )
    axZ.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar) -c*teo,  linestyle=&#39;dashed&#39;)
    axZ.axvline(tep, ymin=0, ymax=zpv(tep, th, alp, lbar)-c*tep ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)

    axZ.plot(tte, z(tte, th, alp, lbar) - c*tte )   
    axZ.plot(tte, zpv(tte, th, alp, lbar) - c*tte )   
    #axZ.plot(tte, th*(1-alp)*lbar**alp  * Lambda(th, alp, 0)**alp/(1+(Lambda(th,alp,0)-1)*tte)**alp  - c*tte, color=&#39;green&#39;)     
    axZ.set_xlim(0,1)
    #axZ.set_ylim(bottom=0, top=None)
    axZ.set_ylabel(r&#39;$z(t_e)-c \cdot t_e $&#39;)
    #Ypct = (z(teg, th, alp, lbar)-c*teg)/(z(teo, th, alp, lbar)-c*teo)
    axZ.set_title(f&#39;z-ct ((zo, zo-zg, %)={zo:0.3f}, {zo-zg:0.3f}, {dwlp: .0%} )&#39;)


    # z prime, r and c plot
    axZP.scatter(teo, zprime(teo, th, alp, lbar), s=40, clip_on=False )
    axZP.scatter(tep, req(tep, th, alp, lbar), s=40, clip_on=False, color=&#39;orange&#39; )
    axZP.scatter(teg, req(teg, th, alp, lbar), s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )


    axZP.axvline(teo, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;)
    axZP.axvline(tep, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)
    axZP.plot(tte, zprime(tte, th, alp, lbar), label=r&#39;$z_o^\prime$&#39; )
    axZP.set_xlim(0,1)
    axZP.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    axZP.set_ylabel(r&#39;$c, r(t_e), z \prime (t_e) $&#39;)
    axZP.axhline(c, color=&#39;red&#39;, linestyle =&#39;dashed&#39;, label=&#39;c&#39;)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    axZP.plot(tte, req(tte, th, alp, lbar),  label= &#39;$r$&#39;)
    axZP.legend()
    
    axP.scatter(th, np.log(lbar), s=40)
    axP.set_xlim(0.9, 3)
    axP.set_ylim(0, 4)
    #prvpart(c=c, alp=alp, full_diag=True, logpop=True, ax = axP)
    allpart(c = c, alp= alp, mu =0, soc_opt= soc_opt, cond_opt=cond_opt, pv_opt=pv_opt, pv_gg=pv_gg,logpop=True, ax=axP)  

    plt.show()
    
    

    

def gaps(th, alp, c):
    dwlp = dwlpct(th, alp, c, lbar)
    dwla = dwl(th, alp, c, lbar)
    lo, lep = leo(teo, th, alp), le(tep, th, alp, 0)
    lto, ltp = lo/(teo+0.001), lep/(tep+0.001)
    display(Math(
       rf&#39;t_e^o ={teo:0.2f}, l_e^o={lo:0.2f}, \bar l_e = {lto:0.2f}&#39;
       ))
    print(f&#39;z(teo)-c te0 = {z(teo, th, alp, lbar)-c*teo:0.2f}, z(tep) = {z(tep, th, alp, lbar)-c*tep:0.2f}, z(teg) = {z(teg, th, alp, lbar)-c*teg:0.2f}&#39;)   
    
    display(Math(
        rf&#39;1st = {z(teo, th, alp, lbar)-c*teo:0.2f}, Pvt = {z(tep, th, alp, lbar)-c*tep:0.2f}, Pvg = {z(teg, th, alp, lbar)-c*teg:0.2f}&#39;        
        ))
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="enclose.Lambda"><code class="name flex">
<span>def <span class="ident">Lambda</span></span>(<span>th, alp, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Key term in expressions. Can return either private or planners
Lambda:
<span><span class="MathJax_Preview">\mu = 0 \rightarrow \Lambda = (\alpha \theta)^\frac{1}{1-\alpha}</span><script type="math/tex; mode=display">\mu = 0 \rightarrow \Lambda = (\alpha \theta)^\frac{1}{1-\alpha}</script></span>
<span><span class="MathJax_Preview">\mu = 1 \rightarrow \Lambda_o = \theta^\frac{1}{1-\alpha}</span><script type="math/tex; mode=display">\mu = 1 \rightarrow \Lambda_o = \theta^\frac{1}{1-\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lambda(th, alp, mu):
    &#39;&#39;&#39; Key term in expressions. Can return either private or planners 
    Lambda:
    $$\\mu = 0 \\rightarrow \\Lambda = (\\alpha \\theta)^\\frac{1}{1-\\alpha}$$
    $$\\mu = 1 \\rightarrow \\Lambda_o = \\theta^\\frac{1}{1-\\alpha}$$
    &#39;&#39;&#39;
    return ( (alp*th)/(1-mu+alp*mu) )**(1/(1-alp))</code></pre>
</details>
</dd>
<dt id="enclose.allpart"><code class="name flex">
<span>def <span class="ident">allpart</span></span>(<span>c=1, alp=0.6666666666666666, mu=0, soc_opt=True, cond_opt=True, pv_opt=False, pv_gg=True, logpop=True, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot loci determining parameter partitions corresponding to
Social (and Conditional Social) Optimum
None, Full, or Partial Enclosure zones
Option: to log plot or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allpart(c = 1, alp= 2/3, mu =0, soc_opt= True, cond_opt=True, pv_opt=False, pv_gg=True,logpop=True, ax=None):
    &#39;&#39;&#39;Plot loci determining parameter partitions corresponding to 
        Social (and Conditional Social) Optimum
        None, Full, or Partial Enclosure zones
        Option: to log plot or not
        &#39;&#39;&#39;
    # for aesthetics we have different plot domains for the different loci    
    lostart, start, finish, step  = 0.8, 1.1, 2.1, 0.01   # domain boundary points
    cv = 1 / alp                          # high TFP gain threshold 
    the_1 = np.arange(start, finish, step)
    the_lo = np.arange(start, cv, step)
    the_hi = np.arange(cv, finish, step)
    the_gg = np.arange(lostart, cv, step)  # below high threshold
    the_d = np.arange(lostart, finish, step)      # above high threshold
    
    ## Social Optima
    lamO = the_1**(1/(1-alp))
    lo0 = ( c / ( (lamO - 1)*(1-alp) )  ) **(1/alp)
    lo1 = lamO * lo0      

    ##### Conditional Optima:  separate plot ranges, each side of cv = theta_hat
    lam_hi =  Lambda(th = the_hi, alp= alp, mu = mu)
    lc  = ( c/(the_lo - 1))**(1/alp)
    lc0 = ( alp*c / (( lam_hi*(1+alp) - alp)*(1-alp))  ) **(1/alp)
    lc1 = ( c     / (the_hi*(1-alp)  ) ) **(1/alp)

    ### Private Decentralized equilibia
    lam = Lambda(th = the_d, alp= alp, mu = mu)
    ld0 = ( alp*c/( (1-alp)*lam)  ) **(1/alp)
    ld1 = ( c / ( the_d*(1-alp) )  ) **(1/alp)
    lamg = Lambda(th = the_gg, alp= alp, mu = mu)
    ldg =  ( alp*c / (1-alp*the_gg) *  (1-lamg)/lamg )**(1/alp)     

    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 8))

    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_linewidth(2)
    ax.spines[&#39;bottom&#39;].set_linewidth(2)
    xlbl = ax.set_xlabel(r&#39;$\theta$&#39;, fontsize=20)
    ylbl = ax.set_ylabel(r&#39;$\overline{l}$&#39;, fontsize=18)
    xpos = list(xlbl.get_position())      # Shift the label on the x-axis a little bit
    ax.xaxis.set_label_coords(xpos[0]+0.41, xpos[1]-0.02)
    ax.set_xticks([])

    if logpop:
        lc0, lc1, lc = np.log(lc0), np.log(lc1), np.log(lc)
        lo0, lo1 = np.log(lo0), np.log(lo1)
        ld0, ld1, ldg = np.log(ld0), np.log(ld1), np.log(ldg)

        ax.set_yticks([])
        ax.autoscale()
        ax.set_ylabel(r&#39;$ln(\overline{l})$&#39;, fontsize=18)
   
    ep = np.max(the_1)+.021  # end point for plot   

    if soc_opt:
        slocus0 = ax.plot(the_1, lo0, color= &#39;black&#39;, alpha=0.2)
        slocus1 = ax.plot(the_1, lo1, color= &#39;black&#39;, alpha=0.2)
        ax.text(ep, np.min(lo0), r&#39;$l^o_0$&#39;, fontsize=16)
        ax.text(ep, np.min(lo1)+.05, r&#39;$l^o_1$&#39;, fontsize=16)

    if cond_opt:
        clocus_lo = ax.plot(the_lo, lc,  color=&#39;blue&#39;, linestyle=&#39;dashed&#39;)
        clocus0 = ax.plot(the_hi, lc0, color= &#39;blue&#39;, linestyle=&#39;dashed&#39;)
        clocus1 = ax.plot(the_hi, lc1, color= &#39;blue&#39;, linestyle=&#39;dashed&#39;,linewidth=2.5)
    
        t3 = ax.text(ep, np.min(lc0), r&#39;$l^c_0$&#39;, fontsize=16)
        t4 = ax.text(ep, np.min(lc1)-.05, r&#39;$l^c_1$&#39;, fontsize=16)
        #t5 = ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_opt:
        oline1 = ax.plot(the_d, ld0, color= &#39;red&#39;)
        bline1 = ax.plot(the_d, ld1, color= &#39;red&#39;)
        bbline3 = ax.plot(the_gg, ldg, color=&#39;red&#39;, linestyle=&#39;dashed&#39;)
        ax.text(ep, np.min(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(lostart, np.max(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(ep, np.min(ld1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        ax.text(lostart, np.max(ld1), r&#39;$l^*_1$&#39;, fontsize=16)
        #ax.text(cv-.1, np.min(lc)-.04, r&#39;$l^*$&#39;, fontsize=16)

    if pv_gg:     # plot just the global game locus below the threshold
        above = len(the_gg)
        ax.plot(the_d[above:], ld0[above:], color= &#39;red&#39;)
        ax.plot(the_d[above:], ld1[above:], color= &#39;red&#39;)
        ax.plot(the_gg, ldg, color=&#39;red&#39;, linestyle=&#39;-&#39;)
        ax.text(ep, np.min(ld0), r&#39;$l^*_0$&#39;, fontsize=16)
        ax.text(ep, np.min(ld1)-.05, r&#39;$l^*_1$&#39;, fontsize=16)
        ax.text(lostart, np.max(ldg)-.04, r&#39;$l^g$&#39;, fontsize=16)

    vline1 = ax.axvline((1-(1-alp)*mu)/alp, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)
    vline2 = ax.axvline(1, ymax=.95, linestyle=&#39;:&#39;, color=&#39;black&#39;)

    ax.text(cv, np.min(lo0)-.5, r&#39;$\frac{1}{\alpha}$&#39;, fontsize=16)
    ax.text(1, np.min(lo0)-.5, r&#39;$1$&#39;, fontsize=16)




    #if cond_opt == False:
    #    fig.savefig(&#39;social_optimum.png&#39;)
    #else:
    #    fig.savefig(&#39;social_opt_cond.png&#39;)</code></pre>
</details>
</dd>
<dt id="enclose.aple"><code class="name flex">
<span>def <span class="ident">aple</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Average product of Labor
<span><span class="MathJax_Preview">APL(t_e, l_e) = \frac{f(T_e, L_e)}{L_e} =
\frac{f(t_e, l_e)}{l_e} \cdot \bar t^{1-\alpha}</span><script type="math/tex; mode=display">APL(t_e, l_e) = \frac{f(T_e, L_e)}{L_e} =
\frac{f(t_e, l_e)}{l_e} \cdot \bar t^{1-\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    r&#39;&#39;&#39;Average product of Labor 
    $$APL(t_e, l_e) = \frac{f(T_e, L_e)}{L_e} =  \frac{f(t_e, l_e)}{l_e} \cdot \bar t^{1-\alpha}$$ 
    &#39;&#39;&#39;
    return f(te,le,a,th)/le  * tlbar**(1-a)</code></pre>
</details>
</dd>
<dt id="enclose.aplu"><code class="name flex">
<span>def <span class="ident">aplu</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Average product of Labor on unenclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Average product of Labor on unenclosed land&#39;&#39;&#39;
    return aple(te, le, a, th, tlbar)</code></pre>
</details>
</dd>
<dt id="enclose.dwl"><code class="name flex">
<span>def <span class="ident">dwl</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns DWL at each paramter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwl(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns DWL at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    tep = tepvt(th,alp,c, lbar, mu=0)
    teg = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = zpv(teg, th, alp, lbar) - c*teg
    return  zo, zg</code></pre>
</details>
</dd>
<dt id="enclose.dwlpct"><code class="name flex">
<span>def <span class="ident">dwlpct</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns actual/potential at each paramter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwlpct(th, alp, c, lbar):
    &#39;&#39;&#39;
    Returns actual/potential at each paramter
    &#39;&#39;&#39;
    teo= teopt(th, alp, c, lbar)
    if th &gt; (1/alp):
        tep = tepvt(th,alp,c, lbar, mu=0)
    else:
        tep = tepvt_g(th,alp,c, lbar, mu=0)

    zo = z(teo, th, alp, lbar) - c*teo
    zg = zpv(tep, th, alp, lbar) - c*tep
    return  zg/zo</code></pre>
</details>
</dd>
<dt id="enclose.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>T, L, a=0.5, th=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Production technology
<span><span class="MathJax_Preview">f(T, L) = \theta \cdot T^{1-\alpha}L^{\alpha}</span><script type="math/tex; mode=display">f(T, L) = \theta \cdot T^{1-\alpha}L^{\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(T, L, a=1/2, th=1):
    r&#39;&#39;&#39;Production technology 
       $$f(T, L) = \theta \cdot T^{1-\alpha}L^{\alpha}$$ 
       &#39;&#39;&#39;
    return th * T**(1-a) * L**a</code></pre>
</details>
</dd>
<dt id="enclose.gaps"><code class="name flex">
<span>def <span class="ident">gaps</span></span>(<span>th, alp, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaps(th, alp, c):
    dwlp = dwlpct(th, alp, c, lbar)
    dwla = dwl(th, alp, c, lbar)
    lo, lep = leo(teo, th, alp), le(tep, th, alp, 0)
    lto, ltp = lo/(teo+0.001), lep/(tep+0.001)
    display(Math(
       rf&#39;t_e^o ={teo:0.2f}, l_e^o={lo:0.2f}, \bar l_e = {lto:0.2f}&#39;
       ))
    print(f&#39;z(teo)-c te0 = {z(teo, th, alp, lbar)-c*teo:0.2f}, z(tep) = {z(tep, th, alp, lbar)-c*tep:0.2f}, z(teg) = {z(teg, th, alp, lbar)-c*teg:0.2f}&#39;)   
    
    display(Math(
        rf&#39;1st = {z(teo, th, alp, lbar)-c*teo:0.2f}, Pvt = {z(tep, th, alp, lbar)-c*tep:0.2f}, Pvg = {z(teg, th, alp, lbar)-c*teg:0.2f}&#39;        
        ))</code></pre>
</details>
</dd>
<dt id="enclose.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>te, th, alp, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Private equilibrium labor share on enclosed for given te when
(1-mu<em>alp</em>mu)<em>APL=MPL<br>
mu = 0:
APLc = MPLe,
le</em> in paper
mu = 1:
MPLc = MPLe,
leo in paper
mu in (0,1)
in between partly secure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def le(te, th, alp, mu):
    &#39;&#39;&#39;Private equilibrium labor share on enclosed for given te when 
       (1-mu*alp*mu)*APL=MPL  
       mu = 0:   APLc = MPLe,   le* in paper
       mu = 1:   MPLc = MPLe,   leo in paper
       mu in (0,1)   in between partly secure
       &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (lam*te)/(1+(lam-1)*te)</code></pre>
</details>
</dd>
<dt id="enclose.leo"><code class="name flex">
<span>def <span class="ident">leo</span></span>(<span>te, th, alp)</span>
</code></dt>
<dd>
<div class="desc"><p>optimal labor allocation (from MPLe = MPLu) given enclosed land share te</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leo(te, th, alp):
    &#39;&#39;&#39;optimal labor allocation (from MPLe = MPLu) given enclosed land share te&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return (lam*te)/(1+lam*te-te)</code></pre>
</details>
</dd>
<dt id="enclose.mple"><code class="name flex">
<span>def <span class="ident">mple</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Marginal product of Labor on enclosed land can be written
<span><span class="MathJax_Preview">MPL(t_e, l_e) = \alpha \cdot \frac{f(t_e, l_e)}{l_e} \bar l^\alpha</span><script type="math/tex; mode=display">MPL(t_e, l_e) = \alpha \cdot \frac{f(t_e, l_e)}{l_e} \bar l^\alpha</script></span>
Since with a Cobb Douglas, $MPL = \alpha \cdot APL$.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mple(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    r&#39;&#39;&#39;Marginal product of Labor on enclosed land can be written
       $$MPL(t_e, l_e) = \alpha \cdot \frac{f(t_e, l_e)}{l_e} \bar l^\alpha$$ 
       Since with a Cobb Douglas, $MPL = \alpha \cdot APL$.&#39;&#39;&#39;
    return a* f(te,le,a,th)/le  * tlbar**(1-a)</code></pre>
</details>
</dd>
<dt id="enclose.mplu"><code class="name flex">
<span>def <span class="ident">mplu</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Marginal product of Labor on unenclosed land
same tech but useful to have other name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mplu(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Marginal product of Labor on unenclosed land
       same tech but useful to have other name&#39;&#39;&#39;
    return mple(te, le, a, th, tlbar)</code></pre>
</details>
</dd>
<dt id="enclose.mpte"><code class="name flex">
<span>def <span class="ident">mpte</span></span>(<span>te, le, a=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Marginal product of Land on enclosed land</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpte(te, le, a=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;Marginal product of Land on enclosed land&#39;&#39;&#39;
    return (1-a)* f(te,le,a,th)/te  * tlbar**(-a)</code></pre>
</details>
</dd>
<dt id="enclose.plotY"><code class="name flex">
<span>def <span class="ident">plotY</span></span>(<span>th=1, lbar=1, alp=0.5, c=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot total income net of clearing costs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotY(th=1, lbar = 1, alp = 0.5,  c = 1, mu=0):
    &#39;&#39;&#39;Plot total income net of clearing costs&#39;&#39;&#39;
    tte = np.linspace(0, 1.0, 20)
    plt.figure(figsize=(8,6))
    plt.title(&#34;Output net of enclosure costs as function of te&#34;)
    plt.plot(tte, ( z(tte, th, alp, lbar) - c*tte ),  label= r&#39;z-cTe&#39; )
    plt.plot(tte, ( z(tte, alp*th, alp, lbar) - c*tte),  label= r&#39;total-cTe&#39; )
    #plt.plot(te, req(te, th, alp, lbar, mu)*te*Tbar,  label= r&#39;$r*Te$&#39;)
    #plt.plot(te, c*te*Tbar,   label= r&#39;$c*Te$&#39;)
    teo = teopt(th, alp, c, lbar)
    plt.axhline(totalq(0, th, alp, lbar, mu), xmin=0, xmax=1, linestyle=&#39;:&#39;, alpha=0.3)
    plt.xlabel(r&#39;$t_e$&#39;)
    plt.xlim(0,1)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="enclose.plotdmg"><code class="name flex">
<span>def <span class="ident">plotdmg</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>like plotmpts but in logs to linearize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotdmg(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    &#39;&#39;&#39;like plotmpts but in logs to linearize&#39;&#39;&#39;
    ll = np.linspace(0.1, 99.9, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, th, tlbar)) ) 
    #plt.plot(lnl, np.log(mplu(te, ll, alp, 1, tlbar)))
    plt.plot(ll, aplu(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)</code></pre>
</details>
</dd>
<dt id="enclose.plotle"><code class="name flex">
<span>def <span class="ident">plotle</span></span>(<span>te=0.5, th=1, alp=0.5, mu=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw edgeworth box and te/le(te) ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotle(te=1/2, th=1, alp=1/2, mu=0.5):
    &#39;&#39;&#39;Draw edgeworth box and te/le(te) ratio&#39;&#39;&#39;
    fig, ax = plt.subplots(figsize=(7,7))
    tte = np.linspace(0,1,50)
    leq = le(te, th, alp, mu=0)
    leop = le(te, th, alp, mu=1)
    ax.set_xlim(0,1)
    ax.set_ylim(0,1)
    ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    ax.plot(tte, le(tte, th, alp, mu=0), linewidth=2)
    ax.plot(tte, le(tte, th, alp, mu=1), linewidth=2)  
    ax.plot(tte, le(tte, th, alp, mu), linewidth=2) 
    ax.plot([0,1],[0, 1],linestyle=&#39;:&#39;)
    ax.plot([0,te],[0, leq],linestyle=&#39;-&#39;)
    ax.scatter(te, leq, label=&#39;private&#39;)
    ax.scatter(te, leop, label=&#39;social&#39;)
    ax.axhline(y=leq, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axhline(y=leop, xmin=0, xmax=te, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leq, linestyle=&#39;:&#39;)
    ax.axvline(x=te, ymin=0, ymax=leop, linestyle=&#39;:&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    ax.set_ylabel(r&#39;$l_e$&#39;, fontsize=15)
    #lam = (th*alp)**(1/(1-alp))
    #ax.text(0.05, 0.9, r&#39;$\theta=$&#39; +f&#39;{th: 2.1f}&#39; r&#39;, $\Lambda =$&#39;
    #      + f&#39;{lam: 3.2f}&#39; + r&#39;, $\ \ \ \frac{l_e}{t_e}=$&#39;
    #      + f&#39;{leq/(te+0.001):3.1f}&#39;, fontsize=16)
    ax.legend(loc=&#39;lower right&#39;, fontsize=14)
    print(leq, leop)</code></pre>
</details>
</dd>
<dt id="enclose.plotmpts"><code class="name flex">
<span>def <span class="ident">plotmpts</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot partial eqn labor demand graph
TODO: not yet working for mu different from 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotmpts(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar, mu = 0):
    &#39;&#39;&#39;Plot partial eqn labor demand graph 
       TODO: not yet working for mu different from 0&#39;&#39;&#39;
    ll = np.linspace(0.0001, 0.9999, 400)
    leop = leo(te, th, alp)         #optimal 
    leam = le(te, th, alp, mu)      #private
    we = weq(te, th, alp, tlbar)
    wo = mple(te, leop, alp, th, tlbar)
    wc = mplu(1-te, 1-leam, alp, 1, tlbar)
    mpe = mple(te, ll, alp, th, tlbar)
    apu = aplu(1-te, 1-ll, alp, 1, tlbar)
    mpu = mplu(1-te, 1-ll, alp, 1, tlbar)

    fig, ax = plt.subplots(figsize=(8,6))
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.plot(ll, mpe, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, apu, linewidth=2, color=&#39;k&#39;)
    ax.plot(ll, mpu, linewidth=2, color=&#39;k&#39;)   
    ax.fill_between(ll, mpe, mpu, 
                    where=(ll&gt;=leam)&amp;(ll&lt;=leop), 
                    hatch= &#39;//&#39;,
                    color=&#39;none&#39;,
                    edgecolor=&#39;k&#39;)
    ax.vlines(x=leam, ymin=0, ymax=we, linestyle=&#39;:&#39;) 
    ax.vlines(x=leop, ymin=0, ymax=wo, 
              linestyle=&#39;:&#39;) 
    ax.axhline(we, linestyle=&#39;:&#39;)
    ax.axhline(wc, linestyle=&#39;:&#39;)
    ax.set_ylim(0,1.5)
    ax.set_xlim(0,1)
    ax.annotate(r&#39;$MP_L^c$&#39;,xy=(0.85, mplu(1-te, 0.15, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-30,20), fontsize=14)
    ax.annotate(r&#39;$AP_L^c$&#39;,xy=(0.65, aplu(1-te, 0.35, alp, 1, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(-24,15), fontsize=14)
    ax.annotate(r&#39;$MP_L^e$&#39;,xy=(0.8,  mple(te, 0.8, alp, th, tlbar)), 
                textcoords=&#34;offset points&#34;, 
                 xytext=(20,-20), fontsize=14)

    xlabels = [&#39;0&#39;, r&#39;$l_e^*(t_e)$&#39;, r&#39;$l_e^o(t_e)$&#39;,&#39;1&#39;]
    ylabels = [&#39;&#39;,r&#39;$w_e$&#39;, r&#39;$w_c$&#39;, r&#39;$w_o$&#39;]
    ax.set_xticks([0, leam, leop, 1],xlabels, fontsize=13)
    #ax.set_yticks([0, we, wc, wo], ylabels, fontsize=13)

    labels = [&#39;A&#39;, &#39;  C&#39;, &#39;  E&#39;,   &#39;&#39;, &#39;&#39;]
    xx = [leam, leam, leop, leam, leop]
    yy = [wc,   we,   wo,   0,    0]    
    for x, y, lab in zip(xx, yy, labels):
        ax.scatter(x, y, marker=&#39;o&#39;, s=30, c =&#39;k&#39;,clip_on=False ) 
        plt.annotate(lab, (x,y), 
                textcoords=&#34;offset points&#34;, # how to position the text
                 xytext=(-5,7), # distance from text to points (x,y)
                 ha=&#39;center&#39;, fontsize=12)
    return fig, ax</code></pre>
</details>
</dd>
<dt id="enclose.plotreq"><code class="name flex">
<span>def <span class="ident">plotreq</span></span>(<span>th=1, alp=0.5, tlbar=1, c=0, wplot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>plot rental rate as function of te
optionally also plot wages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotreq(th=1, alp=1/2, tlbar=1, c=0, wplot=True):
    &#39;&#39;&#39;plot rental rate as function of te
       optionally also plot wages &#39;&#39;&#39;
    tte = np.linspace(0,1,50)
    fig, ax =  plt.subplots(figsize=(5,5))
    r0 = req(0, th, alp, tlbar)
    r1 = req(1, th, alp, tlbar)
    ax.set_xlim(0,1)
    #ax.set_ylim(0,2)
    ax.plot(tte, req(tte, th, alp, tlbar),  label= r&#39;$r$&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;, fontsize=15)
    #ax.text(1.01,r1-0.025,r&#39;$r^*(1)$&#39;,fontsize=13)
    #ax.text(-0.13,r0-0.025,r&#39;$r^*(0)$&#39;,fontsize=13)
    ax.grid()
    ax.axhline(y=c,linestyle=&#39;--&#39;, label=r&#39;$c$&#39;)
    if wplot:
        ax.plot(tte, weq(tte, th, alp, tlbar), label= r&#39;$w$&#39;)
        # plot output net of enclosure costs relative to non-enclose output.
        #ax.plot(tte,  (totalq(tte, th, alp) - c*tte*Tbar)/f(Tbar,Lbar,alp, th),label= r&#39;$net$&#39; )
        
    lam = (th*alp)**(1/(1-alp))
    ax.legend()</code></pre>
</details>
</dd>
<dt id="enclose.plotz"><code class="name flex">
<span>def <span class="ident">plotz</span></span>(<span>th=1, alp=0.5, c=1, lbar=100, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot z(t_e).
input ax to allow use with subplots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotz(th=1, alp=1/2, c=1, lbar=Lbar, ax=None):
    &#39;&#39;&#39;Plot z(t_e).  input ax to allow use with subplots&#39;&#39;&#39;
    if ax is None:
        fig, ax =  plt.subplots(figsize=(5,5))
    teo = teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    ax.scatter(teo, z(teo, th, alp, lbar) - c*teo, s=40, clip_on=False )
    ax.plot(tte, z(tte, th, alp, lbar) - c*tte)
    #ax.plot(tte, z(tte, th, alp, lbar) )
    ax.set_xlim(0,1)
    ax.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar)-c*teo ,  linestyle=&#39;dashed&#39;)
    ax.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    ax.set_ylabel(r&#39;$z(t_e)$&#39;)
    ax.set_title(r&#39;$z(t_e) - c\cdot t_e$&#39;)</code></pre>
</details>
</dd>
<dt id="enclose.plotzprime"><code class="name flex">
<span>def <span class="ident">plotzprime</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotzprime(th, alp, c, lbar):
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    plt.scatter(teo, zprime(teo, th, alp, lbar) , s=40, clip_on=False )
    plt.axhline(c, xmin=0, xmax=1,  linestyle=&#39;dashed&#39;)
    plt.axvline(teo,  linestyle=&#39;dashed&#39;)
    plt.plot(tte, zprime(tte, th, alp, lbar))
    plt.xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    plt.ylabel(r&#39;$z(t_e)$&#39;)
    plt.title(r&#39;$z\prime(t_e) \; \mathrm{vs} \; c$&#39;)
    plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.req"><code class="name flex">
<span>def <span class="ident">req</span></span>(<span>te, th=1, alp=0.5, ltbar=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decentralized Equilibrium rental given t_e
<span><span class="MathJax_Preview">r(t_e) =
\theta f_T(t_e, l_e(t_e)) \cdot \bar l^\alpha</span><script type="math/tex; mode=display">r(t_e) =
\theta f_T(t_e, l_e(t_e)) \cdot \bar l^\alpha</script></span>
<span><span class="MathJax_Preview">r(t_e) =
\frac{(1-\alpha) \theta
\Lambda^\alpha}{(1+(\Lambda-1)t_e)^\alpha}
\cdot \bar l^\alpha</span><script type="math/tex; mode=display">r(t_e) =
\frac{(1-\alpha) \theta
\Lambda^\alpha}{(1+(\Lambda-1)t_e)^\alpha}
\cdot \bar l^\alpha</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def req(te, th=1, alp=1/2, ltbar=1, mu=0):
    r&#39;&#39;&#39;Decentralized Equilibrium rental given t_e
       $$r(t_e) =  \theta f_T(t_e, l_e(t_e)) \cdot \bar l^\alpha$$ 
       $$r(t_e) =  \frac{(1-\alpha) \theta  \Lambda^\alpha}{(1+(\Lambda-1)t_e)^\alpha}  \cdot \bar l^\alpha$$ 

    &#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1-alp)*th * lam**alp * (1+(lam-1)*te)**(-alp) * (ltbar)**(alp)</code></pre>
</details>
</dd>
<dt id="enclose.simplempl"><code class="name flex">
<span>def <span class="ident">simplempl</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplempl(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    plt.figure(figsize=(10,6))
    plt.plot(ll, mple(te, ll, alp, 1, tlbar)) 
    plt.plot(ll, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(ll, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    plt.ylim(0,2)
    plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.simplempl2"><code class="name flex">
<span>def <span class="ident">simplempl2</span></span>(<span>te=0.5, alp=0.5, th=1, tlbar=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplempl2(te=1/2, alp=1/2, th=1, tlbar=Tbar/Lbar):
    ll = np.linspace(0.001, 0.999, 50)
    lnl = np.log(ll)
    plt.figure(figsize=(10,6))
    plt.plot(lnl, np.log(mple(te, ll, alp, 1, tlbar))) 
    plt.plot(lnl, mplu(te, ll, 0.3, th, tlbar))
    plt.plot(lnl, aple(te, ll, alp, 1, tlbar))
    plt.xlabel(&#39;l - labor&#39;)
    #plt.axvline(1-le(te, th, alp, mu=0), linestyle=&#39;-&#39;) 
    #plt.axvline(le(te, alp, th, mu=1), ymin=0, ymax=0.25, linestyle=&#39;:&#39;) 
    #plt.axhline(0.5,  linestyle=&#39;:&#39;) 
    plt.title(&#39;MPL and APL on enclosed and unenclosed lands&#39;)
    #plt.ylim(0,2)
    #plt.xlim(0,1)</code></pre>
</details>
</dd>
<dt id="enclose.teopt"><code class="name flex">
<span>def <span class="ident">teopt</span></span>(<span>th, alp, c, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>Planner enclosure rate. If partial then
<span><span class="MathJax_Preview">t_e^o =
\frac{\bar l}{(\Lambda_o - 1)}
\left [
\frac{(1-\alpha)(\Lambda_o - 1)}{c}
\right ]^\frac{1}{\alpha} - \frac{1}{(\Lambda_o - 1)}
</span><script type="math/tex; mode=display">t_e^o =
\frac{\bar l}{(\Lambda_o - 1)}
\left [
\frac{(1-\alpha)(\Lambda_o - 1)}{c}
\right ]^\frac{1}{\alpha} - \frac{1}{(\Lambda_o - 1)}
</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def teopt(th, alp, c, lbar):
    &#39;&#39;&#39;Planner enclosure rate. If partial then
    $$t_e^o =  \\frac{\\bar l}{(\\Lambda_o - 1)} 
    \\left [   \\frac{(1-\\alpha)(\\Lambda_o - 1)}{c} 
    \\right ]^\\frac{1}{\\alpha} - \\frac{1}{(\\Lambda_o - 1)}
    $$&#39;&#39;&#39;
    lam = th**(1/(1-alp))
    zprime = lambda te : (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) 
    if zprime(0)&lt;c:
        teopt = 0
    elif zprime(1)&gt;c:
        teopt = 1
    else:
        teopt =  ( lbar * (  ((1-alp)*(lam-1))/c)**(1/alp)  - 1)/(lam-1)

    return teopt</code></pre>
</details>
</dd>
<dt id="enclose.tepvt"><code class="name flex">
<span>def <span class="ident">tepvt</span></span>(<span>th, alp, c, lbar, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Private enclosure rate
req(te)= rental rate
r(0)<c
: no enclosure
r(1)>c
: full enclosure
r(0)&gt;c and r(1)&lt;c : partial enclosure
then solve for teopt from foc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tepvt(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate
        req(te)= rental rate 
        r(0)&lt;c  : no enclosure 
        r(1)&gt;c  : full enclosure
        r(0)&gt;c and r(1)&lt;c : partial enclosure
           then solve for teopt from foc

        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    lam = Lambda(th, alp, mu)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    if th&lt;thresh:
        if r0&gt;=c:
            tep = 1
        elif r1&lt;c:
            tep = 0
        else:
            tep = lbar * (lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))
    
    elif th&gt;= thresh:  
        if r1&gt;=c:
            tep = 1
        elif r0&lt;c:
            tep = 0
        else:
            tep = lbar * ( lam/(lam-1)) * (th*(1-alp)/c )**(1/alp) - (1/(lam-1))

    return tep</code></pre>
</details>
</dd>
<dt id="enclose.tepvt_g"><code class="name flex">
<span>def <span class="ident">tepvt_g</span></span>(<span>th, alp, c, lbar, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>Private enclosure rate (global game refinement)
just like pvtpart() but adjust for global game
If theta &lt; theta_hi then global game refinement says enclose fully if
tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tepvt_g(th, alp, c, lbar, mu):
    &#39;&#39;&#39;Private enclosure rate (global game refinement)
        just like pvtpart() but adjust for global game
        If theta &lt; theta_hi then global game refinement says enclose fully if
        tep (from pvtpart) &lt;= 0.5 otherwise no enclosre.
        &#39;&#39;&#39;
    thresh = (1-mu+alp*mu)/alp    
    tep = tepvt(th,alp,c, lbar, mu=0)
    
    tepg = tep
    if (tep==1) or (tep==0):
        tepg = tep
    elif (th &lt; thresh):
        if (tep &gt; 0.5):
            tepg = 0
        elif (tep &lt;= 0.5):
            tepg = 1

    return tepg</code></pre>
</details>
</dd>
<dt id="enclose.threeplots"><code class="name flex">
<span>def <span class="ident">threeplots</span></span>(<span>th, alp, c, lbar=2, soc_opt=True, cond_opt=True, pv_opt=False, pv_gg=True, logpop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>axP
:
left subplot overlap social/private; mostly drawn by allpart()
axZ
:
top right subplot planner's
z(t_e) - c * t_e etc
axZP :
bottom right subplot r vs z' vs c</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threeplots(th, alp, c, lbar=2, soc_opt= True, cond_opt=True, pv_opt=False, pv_gg=True, logpop=False):
    &#39;&#39;&#39;
    axP  :  left subplot overlap social/private; mostly drawn by allpart()
    axZ  :  top right subplot planner&#39;s  z(t_e) - c * t_e etc
    axZP :  bottom right subplot r vs z&#39; vs c
    
    &#39;&#39;&#39;
    fig  = plt.figure(figsize=(14, 8))
    axP  = fig.add_subplot(1,2,1)
    axZ  = fig.add_subplot(2,2,2)
    axZP = fig.add_subplot(2,2,4)
    #axl  = fig.add_subplot(2,4,8)
    
    # z() plot
    teo= teopt(th, alp, c, lbar)
    tte = np.linspace(0,1,20)
    tep = tepvt(th, alp,c, lbar, mu=0)
    teg = tepvt_g(th, alp,c, lbar, mu=0)

    dwlp = dwlpct(th, alp, c, lbar)
    zo, zg = dwl(th, alp, c, lbar)


    # top right z(t_e) - c * t_e plot
    axZ.scatter(teo, z(teo, th, alp, lbar)-c*teo, s=40, clip_on=False)
    axZ.scatter(tep, zpv(tep, th, alp, lbar) - c*tep, s=40, clip_on=False,color=&#39;orange&#39; )  
    axZ.scatter(teg, zpv(teg, th, alp, lbar) - c*teg, s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )
    axZ.axvline(teo, ymin=0, ymax=z(teo, th, alp, lbar) -c*teo,  linestyle=&#39;dashed&#39;)
    axZ.axvline(tep, ymin=0, ymax=zpv(tep, th, alp, lbar)-c*tep ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)

    axZ.plot(tte, z(tte, th, alp, lbar) - c*tte )   
    axZ.plot(tte, zpv(tte, th, alp, lbar) - c*tte )   
    #axZ.plot(tte, th*(1-alp)*lbar**alp  * Lambda(th, alp, 0)**alp/(1+(Lambda(th,alp,0)-1)*tte)**alp  - c*tte, color=&#39;green&#39;)     
    axZ.set_xlim(0,1)
    #axZ.set_ylim(bottom=0, top=None)
    axZ.set_ylabel(r&#39;$z(t_e)-c \cdot t_e $&#39;)
    #Ypct = (z(teg, th, alp, lbar)-c*teg)/(z(teo, th, alp, lbar)-c*teo)
    axZ.set_title(f&#39;z-ct ((zo, zo-zg, %)={zo:0.3f}, {zo-zg:0.3f}, {dwlp: .0%} )&#39;)


    # z prime, r and c plot
    axZP.scatter(teo, zprime(teo, th, alp, lbar), s=40, clip_on=False )
    axZP.scatter(tep, req(tep, th, alp, lbar), s=40, clip_on=False, color=&#39;orange&#39; )
    axZP.scatter(teg, req(teg, th, alp, lbar), s=40, clip_on=False, marker=&#39;X&#39;, color=&#39;red&#39; )


    axZP.axvline(teo, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;)
    axZP.axvline(tep, ymin=0, ymax=1 ,  linestyle=&#39;dashed&#39;, color=&#39;orange&#39;)
    axZP.plot(tte, zprime(tte, th, alp, lbar), label=r&#39;$z_o^\prime$&#39; )
    axZP.set_xlim(0,1)
    axZP.set_xlabel(r&#39;$t_e$&#39;+&#39; -- pct land enclosed&#39;)
    axZP.set_ylabel(r&#39;$c, r(t_e), z \prime (t_e) $&#39;)
    axZP.axhline(c, color=&#39;red&#39;, linestyle =&#39;dashed&#39;, label=&#39;c&#39;)
    r0 = req(0, th, alp, lbar)
    r1 = req(1, th, alp, lbar)
    axZP.plot(tte, req(tte, th, alp, lbar),  label= &#39;$r$&#39;)
    axZP.legend()
    
    axP.scatter(th, np.log(lbar), s=40)
    axP.set_xlim(0.9, 3)
    axP.set_ylim(0, 4)
    #prvpart(c=c, alp=alp, full_diag=True, logpop=True, ax = axP)
    allpart(c = c, alp= alp, mu =0, soc_opt= soc_opt, cond_opt=cond_opt, pv_opt=pv_opt, pv_gg=pv_gg,logpop=True, ax=axP)  

    plt.show()</code></pre>
</details>
</dd>
<dt id="enclose.totalq"><code class="name flex">
<span>def <span class="ident">totalq</span></span>(<span>te, th, alp, lbar, mu)</span>
</code></dt>
<dd>
<div class="desc"><p>total output in the economy given te and mu.
Note costs of enclosure are not subtracted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def totalq(te, th, alp, lbar, mu):
    &#39;&#39;&#39;total output in the economy given te and mu.
       Note costs of enclosure are not subtracted.&#39;&#39;&#39;
    leq = le(te, th, alp, mu)
    return ( th * f(te, leq, alp, th) + f(1-te, 1-leq, alp, 1) ) * lbar**alp </code></pre>
</details>
</dd>
<dt id="enclose.weq"><code class="name flex">
<span>def <span class="ident">weq</span></span>(<span>te, th=1, alp=0.5, tlbar=1, mu=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decentralized Equilibrium wage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weq(te, th=1, alp=1/2, tlbar=1, mu=0):
    &#39;&#39;&#39;Decentralized Equilibrium wage&#39;&#39;&#39;
    lam = Lambda(th, alp, mu)
    return (1+(lam-1)*te)**(1-alp) * (tlbar)**(1-alp)</code></pre>
</details>
</dd>
<dt id="enclose.z"><code class="name flex">
<span>def <span class="ident">z</span></span>(<span>te, th, alp, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>output per unit land net of enclosure cost
<span><span class="MathJax_Preview">z(t_e) = \bar l^\alpha \left(1+(\Lambda_o-1)t_e\right)^{1-\alpha}</span><script type="math/tex; mode=display">z(t_e) = \bar l^\alpha \left(1+(\Lambda_o-1)t_e\right)^{1-\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def z(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost
       $$z(t_e) = \\bar l^\\alpha \\left(1+(\\Lambda_o-1)t_e\\right)^{1-\\alpha}$$ &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return lbar**alp * (1+(lam-1)*te)**(1-alp) </code></pre>
</details>
</dd>
<dt id="enclose.zprime"><code class="name flex">
<span>def <span class="ident">zprime</span></span>(<span>te, th, alp, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>derivative of planner's z(t_e) function
<span><span class="MathJax_Preview">z(t_e) = \bar l^\alpha \cdot (1-\alpha)(\Lambda_o -1) \left(1+(\Lambda_o-1)t_e \right)^{-\alpha}</span><script type="math/tex; mode=display">z(t_e) = \bar l^\alpha \cdot (1-\alpha)(\Lambda_o -1) \left(1+(\Lambda_o-1)t_e \right)^{-\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zprime(te, th, alp, lbar):
    &#39;&#39;&#39;derivative of planner&#39;s z(t_e) function
       $$z(t_e) = \\bar l^\\alpha \\cdot (1-\\alpha)(\\Lambda_o -1) \\left(1+(\\Lambda_o-1)t_e \\right)^{-\\alpha}$$
       &#39;&#39;&#39;
    lam = th**(1/(1-alp))
    return  (1-alp)*(lam-1)*lbar**alp  * (1+(lam-1)*te)**(-alp) </code></pre>
</details>
</dd>
<dt id="enclose.zpv"><code class="name flex">
<span>def <span class="ident">zpv</span></span>(<span>te, th, alp, lbar)</span>
</code></dt>
<dd>
<div class="desc"><p>output per unit land net of enclosure cost
NEED TO ADJUST:
<span><span class="MathJax_Preview">z_d(t_e)= \bar l^\alpha \cdot \frac{ 1+(\frac{\Lambda}{\alpha}-1)t_e}{(1+(\Lambda-1)t_e)^\alpha}</span><script type="math/tex; mode=display">z_d(t_e)= \bar l^\alpha \cdot \frac{ 1+(\frac{\Lambda}{\alpha}-1)t_e}{(1+(\Lambda-1)t_e)^\alpha}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zpv(te, th, alp, lbar):
    &#39;&#39;&#39;output per unit land net of enclosure cost  NEED TO ADJUST:
       $$z_d(t_e)= \\bar l^\\alpha \\cdot \\frac{ 1+(\\frac{\\Lambda}{\\alpha}-1)t_e}{(1+(\\Lambda-1)t_e)^\\alpha}$$
  &#39;&#39;&#39;
    lam = (alp*th)**(1/(1-alp))
    return lbar**alp * (th*te*lam**alp +(1-te))/(1+(lam-1)*te)**alp </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="enclose.Lambda" href="#enclose.Lambda">Lambda</a></code></li>
<li><code><a title="enclose.allpart" href="#enclose.allpart">allpart</a></code></li>
<li><code><a title="enclose.aple" href="#enclose.aple">aple</a></code></li>
<li><code><a title="enclose.aplu" href="#enclose.aplu">aplu</a></code></li>
<li><code><a title="enclose.dwl" href="#enclose.dwl">dwl</a></code></li>
<li><code><a title="enclose.dwlpct" href="#enclose.dwlpct">dwlpct</a></code></li>
<li><code><a title="enclose.f" href="#enclose.f">f</a></code></li>
<li><code><a title="enclose.gaps" href="#enclose.gaps">gaps</a></code></li>
<li><code><a title="enclose.le" href="#enclose.le">le</a></code></li>
<li><code><a title="enclose.leo" href="#enclose.leo">leo</a></code></li>
<li><code><a title="enclose.mple" href="#enclose.mple">mple</a></code></li>
<li><code><a title="enclose.mplu" href="#enclose.mplu">mplu</a></code></li>
<li><code><a title="enclose.mpte" href="#enclose.mpte">mpte</a></code></li>
<li><code><a title="enclose.plotY" href="#enclose.plotY">plotY</a></code></li>
<li><code><a title="enclose.plotdmg" href="#enclose.plotdmg">plotdmg</a></code></li>
<li><code><a title="enclose.plotle" href="#enclose.plotle">plotle</a></code></li>
<li><code><a title="enclose.plotmpts" href="#enclose.plotmpts">plotmpts</a></code></li>
<li><code><a title="enclose.plotreq" href="#enclose.plotreq">plotreq</a></code></li>
<li><code><a title="enclose.plotz" href="#enclose.plotz">plotz</a></code></li>
<li><code><a title="enclose.plotzprime" href="#enclose.plotzprime">plotzprime</a></code></li>
<li><code><a title="enclose.req" href="#enclose.req">req</a></code></li>
<li><code><a title="enclose.simplempl" href="#enclose.simplempl">simplempl</a></code></li>
<li><code><a title="enclose.simplempl2" href="#enclose.simplempl2">simplempl2</a></code></li>
<li><code><a title="enclose.teopt" href="#enclose.teopt">teopt</a></code></li>
<li><code><a title="enclose.tepvt" href="#enclose.tepvt">tepvt</a></code></li>
<li><code><a title="enclose.tepvt_g" href="#enclose.tepvt_g">tepvt_g</a></code></li>
<li><code><a title="enclose.threeplots" href="#enclose.threeplots">threeplots</a></code></li>
<li><code><a title="enclose.totalq" href="#enclose.totalq">totalq</a></code></li>
<li><code><a title="enclose.weq" href="#enclose.weq">weq</a></code></li>
<li><code><a title="enclose.z" href="#enclose.z">z</a></code></li>
<li><code><a title="enclose.zprime" href="#enclose.zprime">zprime</a></code></li>
<li><code><a title="enclose.zpv" href="#enclose.zpv">zpv</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>